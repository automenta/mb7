<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Semantic Editor</title>
    <style>
        body { font-family: sans-serif; margin: 1em; }
        #editor {
            border: 1px solid #ccc;
            padding: 0.5em;
            cursor: text;
            min-height: 100px;
        }
        .tag {
            background-color: #e0f7fa;
            border: 1px solid #80deea;
            border-radius: 4px;
            padding: 2px 5px;
            margin: 0 2px;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
        }
        .tag.conditional {
            background-color: #fff3e0;
            border-color: #ffcc80;
        }
        .tag input,
        .tag select {
            border: none;
            background: transparent;
            font-size: inherit;
            padding: 0;
            margin: 0;
            outline: none;
        }
        .tag select {
            appearance: none;
            padding: 0 2px;
            cursor: pointer;
        }
        .tag .remove-tag {
            margin-left: 5px;
            cursor: pointer;
            color: #888;
            font-size: smaller;
        }
        .color-preview {
            width: 1em;
            height: 1em;
            display: inline-block;
            border: 1px solid #ccc;
            margin-left: 2px;
        }
        .unit-label {
            font-style: italic;
            margin-left: 2px;
        }
        /* Suggestion Dropdown Styles */
        #suggestion-dropdown {
            position: absolute;
            display: none;
            background-color: white;
            border: 1px solid #ccc;
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        #suggestion-dropdown div {
            cursor: pointer;
            padding: 2px 5px;
        }
        #suggestion-dropdown div:hover { background-color: #eee; }
        /* Autosuggest Underline */
        .autosuggest {
            text-decoration: underline dotted;
            cursor: pointer;
            position: relative;
        }
        .autosuggest:hover {
            background-color: rgba(255, 255, 0, 0.2);
        }
        #toolbar {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }
        #toolbar .group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
<script>
    /* ---------------------- Helper ---------------------- */
    const createElement = (tag, attrs = {}, text = "") => {
        const el = document.createElement(tag);
        for (const [key, value] of Object.entries(attrs)) {
            if (key.startsWith("on") && typeof value === "function") {
                el.addEventListener(key.substring(2), value);
            } else {
                el.setAttribute(key, value);
            }
        }
        if (text) el.textContent = text;
        return el;
    };

    /* ---------------------- Ontology Data ---------------------- */
    const ontology = {
        Physical: [
            { name: "Mass", type: "number", unit: "kg", emoji: "âš–ï¸", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Length", type: "number", unit: "m", emoji: "ðŸ“", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Temperature", type: "number", unit: "Â°C", emoji: "ðŸŒ¡ï¸", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Location", type: "location", emoji: "ðŸ“", modes: { is: "is at", "is within": "is within" }, editor: "map" },
            { name: "Color", type: "color", emoji: "ðŸŽ¨", modes: { is: "is" } }
        ],
        Emotion: [
            { name: "Happiness", type: "range", emoji: "ðŸ˜Š", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Sadness", type: "range", emoji: "ðŸ˜¢", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Anger", type: "range", emoji: "ðŸ˜¡", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } }
        ],
        Business: [
            { name: "Revenue", type: "number", unit: "USD", emoji: "ðŸ’°", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Product", type: "list", emoji: "ðŸ“¦", options: ["Software", "Hardware", "Service"], modes: { "is one of": "is" } },
            { name: "Customer", type: "list", emoji: "ðŸ‘¥", options: ["B2B", "B2C", "Government"], modes: { "is one of": "is" } }
        ],
        Time: [
            { name: "Time", type: "time", emoji: "â°", modes: { is: "is at", "is between": "is between", "is before": "is before", "is after": "is after" }, editor: "calendar" }
        ],
        Data: [
            { name: "List", type: "list", emoji: "ðŸ”–", options: [], modes: { "is one of": "is" } }
        ]
    };

    /* ---------------------- UI Components ---------------------- */
    class UIComponent {
        constructor() {
            this.element = null;
        }
        getElement() { return this.element; }
    }

    class InputComponent extends UIComponent {
        constructor(value, onChange) {
            super();
            this.value = value;
            this.onChange = onChange;
        }
    }

    class NumberInput extends InputComponent {
        constructor(value, onChange, placeholder = "") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "number", placeholder: this.placeholder });
            input.value = this.value ?? "";
            input.addEventListener("input", (e) => {
                const parsed = parseFloat(e.target.value || 0);
                if (!isNaN(parsed)) this.onChange(parsed);
            });
            return input;
        }
    }

    class TextInput extends InputComponent {
        constructor(value, onChange, placeholder = "") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "text", placeholder: this.placeholder });
            input.value = this.value ?? "";
            input.addEventListener("input", (e) => this.onChange(e.target.value));
            return input;
        }
    }

    class ListInput extends InputComponent {
        constructor(options, value, onChange) {
            super(value, onChange);
            this.options = options;
            this.element = this.createSelect();
        }
        createSelect() {
            const select = createElement("select");
            this.options.forEach(opt => select.appendChild(new Option(opt, opt)));
            select.value = this.value || this.options[0];
            select.addEventListener("change", () => this.onChange(select.value));
            return select;
        }
    }

    class LocationInput extends InputComponent {
        constructor(value, onChange, placeholder = "Lat, Lng") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "text", placeholder: this.placeholder });
            input.value = this.value ? `${this.value.lat}, ${this.value.lng}` : "";
            input.addEventListener("input", (e) => {
                const parts = e.target.value.split(",");
                const lat = parseFloat(parts[0]?.trim());
                const lng = parseFloat(parts[1]?.trim());
                this.onChange(!isNaN(lat) && !isNaN(lng) ? { lat, lng } : null);
            });
            return input;
        }
    }

    class ColorInput extends InputComponent {
        constructor(value, onChange) {
            super(value, onChange);
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "color" });
            input.value = this.value || "#000000";
            input.addEventListener("input", (e) => this.onChange(e.target.value));
            return input;
        }
    }

    class ColorPreview extends UIComponent {
        constructor(color) {
            super();
            this.element = createElement("span", { class: "color-preview" });
            this.setColor(color);
        }
        setColor(color) { this.element.style.backgroundColor = color; }
    }

    class UnitLabel extends UIComponent {
        constructor(unit) {
            super();
            this.element = createElement("span", { class: "unit-label" }, ` ${unit || ""}`);
        }
    }

    class RemoveTagButton extends UIComponent {
        constructor(onRemove) {
            super();
            this.onRemove = onRemove;
            this.element = createElement("span", { class: "remove-tag" }, "x");
            this.element.addEventListener("click", (e) => {
                e.stopPropagation();
                onRemove();
            });
        }
    }

    /* ---------------------- Tag Input Controls ---------------------- */
    class TagInputControl extends UIComponent {
        constructor(tag) {
            super();
            this.tag = tag;
        }
        getElement() { throw new Error("Abstract method 'getElement' must be implemented"); }
    }

    class NumericTagInputControl extends TagInputControl {
        getElement() {
            const frag = document.createDocumentFragment();
            const d = this.tag.data;
            const update = () => this.tag.updateData();
            const createNumInput = (key, placeholder) =>
                new NumberInput(d[key], (v) => { d[key] = v; update(); }, placeholder).getElement();
            if (d.mode === "is") {
                frag.appendChild(createNumInput("value", ""));
            } else if (d.mode === "is between") {
                frag.appendChild(createNumInput("min", "Min"));
                frag.appendChild(document.createTextNode(" and "));
                frag.appendChild(createNumInput("max", "Max"));
            } else if (d.mode === "is below" || d.mode === "is above") {
                frag.appendChild(createNumInput(d.mode === "is below" ? "max" : "min", d.mode === "is below" ? "Max" : "Min"));
            }
            frag.appendChild(new UnitLabel(d.unit).getElement());
            return frag;
        }
    }

    class ListTagInputControl extends TagInputControl {
        getElement() {
            return new ListInput(this.tag.data.options, this.tag.data.value, (v) => {
                this.tag.data.value = v;
                this.tag.updateData();
            }).getElement();
        }
    }

    class LocationTagInputControl extends TagInputControl {
        getElement() {
            return new LocationInput(this.tag.data.value, (v) => {
                this.tag.data.value = v;
                this.tag.updateData();
            }).getElement();
        }
    }

    class ColorTagInputControl extends TagInputControl {
        getElement() {
            const frag = document.createDocumentFragment();
            frag.appendChild(new ColorInput(this.tag.data.value, (v) => {
                this.tag.data.value = v;
                this.tag.updateData();
            }).getElement());
            frag.appendChild(new ColorPreview(this.tag.data.value).getElement());
            return frag;
        }
    }

    class TimeTagInputControl extends TagInputControl {
        getElement() {
            const frag = document.createDocumentFragment();
            const update = () => this.tag.updateData();
            const createTextInput = (key, placeholder) =>
                new TextInput(this.tag.data[key], (v) => { this.tag.data[key] = v; update(); }, placeholder).getElement();
            if (this.tag.data.mode === "is") {
                frag.appendChild(createTextInput("value", ""));
            } else if (this.tag.data.mode === "is between") {
                frag.appendChild(createTextInput("min", "Start Time"));
                frag.appendChild(document.createTextNode(" and "));
                frag.appendChild(createTextInput("max", "End Time"));
            } else if (this.tag.data.mode === "is before" || this.tag.data.mode === "is after") {
                frag.appendChild(createTextInput(this.tag.data.mode === "is before" ? "max" : "min",
                    this.tag.data.mode === "is before" ? "Before" : "After"));
            }
            return frag;
        }
    }

    /* ---------------------- Tag Component ---------------------- */
    class Tag extends UIComponent {
        constructor(tag) {
            super();
            // Copy tag data and set default mode if not provided.
            this.data = { ...tag, mode: tag.mode || Object.keys(tag.modes)[0] };
            this.initializeValues();
            this.element = this.createElement();
            this.updateData();
        }
        initializeValues() {
            const d = this.data;
            if (["number", "range"].includes(d.type))
                d.value = d.value ?? 0;
            else if (d.type === "list")
                d.value = d.value ?? (d.options?.[0] || "");
            else if (d.type === "color")
                d.value = d.value ?? "#000000";
        }
        createElement() {
            const e = createElement("span", { class: `tag ${this.isConditional() ? "conditional" : ""}`, contenteditable: "false" });
            if (this.data.emoji) {
                const emojiSpan = createElement("span", { class: "tag-emoji" }, this.data.emoji + " ");
                e.appendChild(emojiSpan);
            }
            e.appendChild(document.createTextNode(`${this.data.name} `));
            e.appendChild(this.createModeSelect());
            this.rebuildInputs(e);
            return e;
        }
        createModeSelect() {
            const select = createElement("select");
            for (const mode in this.data.modes) {
                select.appendChild(new Option(this.data.modes[mode], mode));
            }
            select.value = this.data.mode;
            select.addEventListener("change", () => {
                this.data.mode = select.value;
                this.adjustValuesForMode();
                this.rebuildInputs(this.element);
                this.updateData();
            });
            return select;
        }
        isConditional() {
            return this.data.mode !== "is" && String(this.data.mode).startsWith("is");
        }
        adjustValuesForMode() {
            const d = this.data;
            if (d.mode === "is between") {
                d.min = d.min ?? 0; d.max = d.max ?? 0;
            } else if (d.mode === "is below") {
                d.max = d.max ?? 0; d.min = null;
            } else if (d.mode === "is above") {
                d.min = d.min ?? 0; d.max = null;
            } else {
                d.value = d.value ?? (d.type === "list" ? d.options[0] : 0);
            }
        }
        rebuildInputs(tagEl) {
            // Remove any previous inputs (leaving the mode select intact)
            tagEl.querySelectorAll("input, select:not(:first-of-type), .color-preview, .unit-label")
                .forEach(el => el.remove());
            let control;
            switch (this.data.type) {
                case "number":
                case "range":
                    control = new NumericTagInputControl(this);
                    break;
                case "list":
                    control = new ListTagInputControl(this);
                    break;
                case "location":
                    control = new LocationTagInputControl(this);
                    break;
                case "color":
                    control = new ColorTagInputControl(this);
                    break;
                case "time":
                    control = new TimeTagInputControl(this);
                    break;
            }
            if (control) tagEl.appendChild(control.getElement());
            tagEl.appendChild(new RemoveTagButton(() => tagEl.remove()).getElement());
        }
        updateData() {
            this.element.dataset.tagData = JSON.stringify(this.data);
        }
    }

    /* ---------------------- Suggestion Dropdown ---------------------- */
    class SuggestionDropdown extends UIComponent {
        constructor() {
            super();
            this.element = createElement("div", { id: "suggestion-dropdown" });
            this.hide();
            document.body.appendChild(this.element);
            this.selectedIndex = -1;
        }
        show(suggestions, x, y, onSelect) {
            this.element.innerHTML = "";
            suggestions.forEach((sugg, i) => {
                const display = (sugg.tagData.emoji ? sugg.tagData.emoji + " " : "") + sugg.displayText;
                const optionEl = createElement("div", {}, display);
                optionEl.dataset.index = i;
                optionEl.addEventListener("click", () => {
                    onSelect(sugg);
                    this.hide();
                });
                this.element.appendChild(optionEl);
            });
            this.element.style.left = `${x}px`;
            this.element.style.top = `${y}px`;
            this.element.style.display = "block";
            this.selectedIndex = -1;
            this.updateSelection();
        }
        hide() { this.element.style.display = "none"; }
        moveSelection(dir) {
            const count = this.element.children.length;
            if (!count) return;
            this.selectedIndex = (this.selectedIndex + dir + count) % count;
            this.updateSelection();
        }
        updateSelection() {
            Array.from(this.element.children).forEach((child, i) => {
                child.style.backgroundColor = (i === this.selectedIndex ? "#ddd" : "transparent");
            });
        }
        getSelectedSuggestion() {
            return (this.selectedIndex >= 0 && this.selectedIndex < this.element.children.length)
                ? this.element.children[this.selectedIndex].textContent
                : null;
        }
    }

    /* ---------------------- Ontology Browser ---------------------- */
    class OntologyBrowser extends UIComponent {
        constructor(ontology, onTagSelect) {
            super();
            this.ontology = ontology;
            this.onTagSelect = onTagSelect;
            this.element = this.createBrowser();
        }
        createBrowser() {
            const browser = createElement("div", { id: "ontology-browser" });
            for (const category in this.ontology) {
                const catDiv = createElement("div", { class: "category" }, category);
                this.ontology[category].forEach(tag => {
                    const tagItem = createElement("div", { class: "tag-item" }, (tag.emoji ? tag.emoji + " " : "") + tag.name);
                    tagItem.addEventListener("click", () => this.onTagSelect(new Tag(tag)));
                    catDiv.appendChild(tagItem);
                });
                browser.appendChild(catDiv);
            }
            return browser;
        }
        getElement() { return this.element; }
        showAt(x, y) {
            this.element.style.display = "block";
            this.element.style.left = `${x}px`;
            this.element.style.top = `${y}px`;
        }
        hide() { this.element.style.display = "none"; }
    }

    /* ---------------------- Editor ---------------------- */
    class Editor {
        constructor(ontology) {
            this.ontology = ontology;
            this.suggestionTimeout = null;
            this.container = createElement("div", { class: "semantic-editor-container" });

            // --- Toolbar Setup ---
            this.toolbar = createElement("div", { id: "toolbar" });
            this.container.appendChild(this.toolbar);

            // Load & Save group.
            const loadSaveGroup = createElement("div", { class: "group" });
            this.loadBtn = createElement("button", { id: "load-content" }, "Load");
            this.saveBtn = createElement("button", { id: "save-content" }, "Save");
            loadSaveGroup.appendChild(this.loadBtn);
            loadSaveGroup.appendChild(this.saveBtn);
            this.toolbar.appendChild(loadSaveGroup);

            // Richâ€‘text style buttons.
            const styleGroup = createElement("div", { id: "style-buttons", class: "group" });
            this.boldBtn = createElement("button", { id: "bold-btn", title: "Bold (Ctrl+B)" });
            this.boldBtn.innerHTML = "<strong>B</strong>";
            this.italicBtn = createElement("button", { id: "italic-btn", title: "Italic (Ctrl+I)" });
            this.italicBtn.innerHTML = "<em>I</em>";
            this.underlineBtn = createElement("button", { id: "underline-btn", title: "Underline (Ctrl+U)" });
            this.underlineBtn.innerHTML = "<u>U</u>";
            this.strikeBtn = createElement("button", { id: "strike-btn", title: "Strike Through" }, "S");
            this.clearFormatBtn = createElement("button", { id: "clear-format-btn", title: "Clear Formatting" }, "Unformat");
            styleGroup.appendChild(this.boldBtn);
            styleGroup.appendChild(this.italicBtn);
            styleGroup.appendChild(this.underlineBtn);
            styleGroup.appendChild(this.strikeBtn);
            styleGroup.appendChild(this.clearFormatBtn);
            this.toolbar.appendChild(styleGroup);

            // Undo / Redo buttons.
            const undoRedoGroup = createElement("div", { id: "undoredo-buttons", class: "group" });
            this.undoBtn = createElement("button", { id: "undo-btn", title: "Undo (Ctrl+Z)" }, "Undo");
            this.redoBtn = createElement("button", { id: "redo-btn", title: "Redo (Ctrl+Y)" }, "Redo");
            undoRedoGroup.appendChild(this.undoBtn);
            undoRedoGroup.appendChild(this.redoBtn);
            this.toolbar.appendChild(undoRedoGroup);

            // Tag Dropdowns.
            this.tagDropdownsContainer = createElement("div", { id: "tag-dropdowns", class: "group" });
            this.toolbar.appendChild(this.tagDropdownsContainer);

            // --- Editor Area ---
            this.editorArea = createElement("div", { id: "editor", contenteditable: "true" },
                "Type your freeâ€‘form text here. As you type, eligible words are underlined. Click an underlined word to see ontology suggestions."
            );
            this.container.appendChild(this.editorArea);
            document.body.appendChild(this.container);

            // Create auxiliary UI components.
            this.ontologyBrowser = new OntologyBrowser(this.ontology, this.insertTagFromOntology.bind(this));
            this.container.appendChild(this.ontologyBrowser.getElement());
            this.ontologyBrowser.hide();

            this.suggestionDropdown = new SuggestionDropdown();

            this.setupTagDropdowns();
            this.setupEventListeners();
        }
        setupTagDropdowns() {
            for (const category in this.ontology) {
                const select = createElement("select", { class: "tag-dropdown" });
                const defaultOption = createElement("option", { disabled: true, selected: true }, category);
                select.appendChild(defaultOption);
                this.ontology[category].forEach(tag => {
                    const optionText = (tag.emoji ? tag.emoji + " " : "") + tag.name;
                    select.appendChild(new Option(optionText, JSON.stringify(tag)));
                });
                select.addEventListener("change", (e) => {
                    try {
                        const tag = JSON.parse(e.target.value);
                        this.insertTagAtSelection(new Tag(tag));
                        e.target.selectedIndex = 0; // Reset selection.
                    } catch (err) {
                        console.error("Error parsing tag data:", err);
                    }
                });
                this.tagDropdownsContainer.appendChild(select);
            }
        }
        setupEventListeners() {
            // Richâ€‘text buttons.
            this.boldBtn.addEventListener("click", () => document.execCommand('bold'));
            this.italicBtn.addEventListener("click", () => document.execCommand('italic'));
            this.underlineBtn.addEventListener("click", () => document.execCommand('underline'));
            this.strikeBtn.addEventListener("click", () => document.execCommand('strikeThrough'));
            this.clearFormatBtn.addEventListener("click", () => document.execCommand('removeFormat'));
            this.undoBtn.addEventListener("click", () => document.execCommand('undo'));
            this.redoBtn.addEventListener("click", () => document.execCommand('redo'));

            this.loadBtn.addEventListener("click", () => {
                const saved = localStorage.getItem("semanticEditorContent");
                if (saved) this.deserialize(saved);
            });
            this.saveBtn.addEventListener("click", () => {
                localStorage.setItem("semanticEditorContent", this.serialize());
                alert("Content saved!");
            });

            // Update autosuggest underlines.
            this.editorArea.addEventListener("keyup", () => {
                clearTimeout(this.suggestionTimeout);
                if (this.suggestionDropdown.element.style.display === "block") return;
                this.suggestionTimeout = setTimeout(() => this.applyAutosuggestUnderlines(), 300);
            });
            this.editorArea.addEventListener("click", () => this.suggestionDropdown.hide());

            // Global hotkeys for suggestion dropdown.
            document.addEventListener("keydown", (e) => {
                if (this.suggestionDropdown.element.style.display === "block") {
                    switch (e.key) {
                        case "ArrowDown":
                            e.preventDefault();
                            this.suggestionDropdown.moveSelection(1);
                            break;
                        case "ArrowUp":
                            e.preventDefault();
                            this.suggestionDropdown.moveSelection(-1);
                            break;
                        case "Enter":
                            e.preventDefault();
                            const selText = this.suggestionDropdown.getSelectedSuggestion();
                            if (selText) {
                                const suggestion = this.findSuggestion(selText);
                                if (suggestion) this.insertTagFromSuggestion(suggestion);
                            }
                            this.suggestionDropdown.hide();
                            break;
                        case "Escape":
                            e.preventDefault();
                            this.suggestionDropdown.hide();
                            break;
                    }
                }
            });

            // Hide suggestion dropdown when clicking outside.
            document.addEventListener("click", (e) => {
                if (!this.editorArea.contains(e.target) && !this.ontologyBrowser.getElement().contains(e.target))
                    this.suggestionDropdown.hide();
            });
        }
        insertTagAtSelection(tag) {
            this.editorArea.focus();
            const sel = window.getSelection();
            if (!sel.rangeCount || !this.editorArea.contains(sel.anchorNode)) {
                sel.removeAllRanges();
                const range = document.createRange();
                range.selectNodeContents(this.editorArea);
                range.collapse(false);
                sel.addRange(range);
            }
            const range = sel.getRangeAt(0);
            range.deleteContents();
            range.insertNode(tag.getElement());
            range.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range);
        }
        insertTagFromOntology(tag) {
            this.insertTagAtSelection(tag);
            this.ontologyBrowser.hide();
        }
        insertTagFromSuggestion(sugg, autosuggestSpan = null) {
            if (autosuggestSpan) {
                autosuggestSpan.parentNode.replaceChild(new Tag(sugg.tagData).getElement(), autosuggestSpan);
            } else {
                this.insertTagAtSelection(new Tag(sugg.tagData));
            }
        }
        serialize() {
            const clone = this.editorArea.cloneNode(true);
            clone.querySelectorAll(".tag").forEach(tagEl => {
                const data = JSON.parse(tagEl.dataset.tagData);
                tagEl.replaceWith(document.createTextNode(`[TAG:${JSON.stringify(data)}]`));
            });
            return clone.textContent;
        }
        deserialize(text) {
            this.editorArea.innerHTML = "";
            const tagRegex = /\[TAG:(.*?)\]/g;
            let lastIndex = 0, match;
            while ((match = tagRegex.exec(text)) !== null) {
                if (match.index > lastIndex)
                    this.editorArea.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                try {
                    const data = JSON.parse(match[1]);
                    this.editorArea.appendChild(new Tag(data).getElement());
                } catch (e) {
                    console.error("Error parsing tag:", e);
                    this.editorArea.appendChild(document.createTextNode(match[0]));
                }
                lastIndex = tagRegex.lastIndex;
            }
            if (lastIndex < text.length)
                this.editorArea.appendChild(document.createTextNode(text.substring(lastIndex)));
        }
        findSuggestion(text) {
            for (const cat in this.ontology) {
                for (const tag of this.ontology[cat]) {
                    if (tag.name === text) return { displayText: tag.name, tagData: tag };
                }
            }
            return null;
        }
        matchesOntology(word) {
            word = word.toLowerCase();
            for (const cat in this.ontology) {
                for (const tag of this.ontology[cat]) {
                    if (tag.name.toLowerCase().startsWith(word)) return true;
                }
            }
            return false;
        }
        applyAutosuggestUnderlines() {
            const walker = document.createTreeWalker(this.editorArea, NodeFilter.SHOW_TEXT, {
                acceptNode: (n) =>
                    n.parentNode.closest(".tag, .autosuggest") ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
            });
            const regex = /\b([a-zA-Z]{3,})\b/g;
            let node;
            while ((node = walker.nextNode())) {
                if (!node.nodeValue.trim()) continue;
                let match, wrap = false;
                regex.lastIndex = 0;
                while ((match = regex.exec(node.nodeValue)) !== null) {
                    if (this.matchesOntology(match[1])) { wrap = true; break; }
                }
                if (wrap) this.wrapMatchesInTextNode(node, regex);
            }
        }
        wrapMatchesInTextNode(textNode, regex) {
            const parent = textNode.parentNode;
            const text = textNode.nodeValue;
            let match, lastIndex = 0;
            const frag = document.createDocumentFragment();
            regex.lastIndex = 0;
            while ((match = regex.exec(text)) !== null) {
                const word = match[1],
                    start = match.index,
                    end = regex.lastIndex;
                if (start > lastIndex)
                    frag.appendChild(document.createTextNode(text.substring(lastIndex, start)));
                if (this.matchesOntology(word)) {
                    const span = document.createElement("span");
                    span.className = "autosuggest";
                    span.textContent = word;
                    span.addEventListener("click", (e) => {
                        e.stopPropagation();
                        this.showSuggestionForSpan(span);
                    });
                    frag.appendChild(span);
                } else {
                    frag.appendChild(document.createTextNode(word));
                }
                lastIndex = end;
            }
            if (lastIndex < text.length)
                frag.appendChild(document.createTextNode(text.substring(lastIndex)));
            parent.replaceChild(frag, textNode);
        }
        showSuggestionForSpan(span) {
            const word = span.textContent;
            const suggestions = [];
            for (const cat in this.ontology) {
                for (const tag of this.ontology[cat]) {
                    if (tag.name.toLowerCase().startsWith(word.toLowerCase()))
                        suggestions.push({ displayText: tag.name, tagData: tag });
                }
            }
            if (suggestions.length) {
                const r = span.getBoundingClientRect();
                this.suggestionDropdown.show(suggestions, r.left + window.scrollX, r.bottom + window.scrollY,
                    (sugg) => this.insertTagFromSuggestion(sugg, span));
            }
        }
    }

    /* ---------------------- Instantiate Editor ---------------------- */
    new Editor(ontology);
</script>
</body>
</html>
