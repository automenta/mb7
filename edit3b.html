<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Text Editor</title>
    <style>
        /* (Styles - Same as before, suggestion dropdown styles included) */
        body { font-family: sans-serif; }
        #editor { border: 1px solid #ccc; padding: 10px; min-height: 200px; cursor: text; margin-bottom: 10px; white-space: pre-wrap; }
        .tag { background-color: #e0f7fa; border: 1px solid #80deea; border-radius: 4px; padding: 2px 5px; margin: 0 2px; display: inline-flex; align-items: center; cursor: pointer; }
        .tag.conditional { background-color: #fff3e0; border-color: #ffcc80; }
        .tag input, .tag select { border: none; background: transparent; font-size: inherit; padding: 0; margin: 0; width: auto; outline: none; }
        .tag select { -webkit-appearance: none; -moz-appearance: none; appearance: none; padding: 0 2px; cursor: pointer; }
        .tag select::-ms-expand { display: none; }
        .tag .remove-tag { margin-left: 5px; cursor: pointer; color: #888; font-size: smaller; }
        .color-preview { width: 1em; height: 1em; display: inline-block; border: 1px solid #ccc; margin-left: 2px;}
        #ontology-browser { border: 1px solid #ccc; padding: 10px; width: 250px; height: 300px; overflow-y: auto; display: none; position: absolute; background-color: white; z-index: 50; }
        #ontology-browser .category { font-weight: bold; margin-top: 1em; }
        #ontology-browser .tag-item { cursor: pointer; padding: 2px 5px; }
        #ontology-browser .tag-item:hover { background-color: #eee; }
        #serialization-output { width: 100%; height: 100px; margin-top: 10px; }
        /* Styling for suggestion dropdown */
        #suggestion-dropdown {
            position: absolute;
            display: none;
            background-color: white;
            border: 1px solid #ccc;
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        #suggestion-dropdown div {
            padding: 5px;
            cursor: pointer;
        }
        #suggestion-dropdown div:hover {
            background-color: #eee;
        }
    </style>
</head>
<body>

<h1>Semantic Text Editor</h1>

<div id="editor" contenteditable="true"></div>
<button id="show-ontology">Show Ontology</button>
<button id="serialize">Serialize</button>

<div id="ontology-browser"></div>
<div id="suggestion-dropdown"></div>
<textarea id="serialization-output" placeholder="Serialization will appear here"></textarea>

<script>
    const editor = document.getElementById('editor');
    const ontologyBrowser = document.getElementById('ontology-browser');
    const showOntologyButton = document.getElementById('show-ontology');
    const serializeButton = document.getElementById('serialize');
    const serializationOutput = document.getElementById('serialization-output');
    const suggestionDropdown = document.getElementById('suggestion-dropdown');

    // --- Ontology Definition (Enhanced) ---
    const ontology = {
        "Physical": [
            { name: "Mass", type: "number", unit: "kg", modes: { "is": "is", "is between": "is between", "is below": "is below", "is above": "is above" }, prefixes: ["The mass", "A mass"] },
            { name: "Length", type: "number", unit: "m", modes: { "is": "is", "is between": "is between", "is below": "is below", "is above": "is above" }, prefixes: ["The length", "A length"] },
            { name: "Temperature", type: "number", unit: "Â°C", modes: { "is": "is", "is between": "is between", "is below": "is below", "is above": "is above" }, prefixes: ["The temperature", "A temperature"] },
            { name: "Location", type: "location", modes: { "is": "is at", "is within": "is within" }, editor: 'map', prefixes: ["The location", "A location"] },
            { name: "Color", type: "color", modes: { "is": "is" }, prefixes: ["The color", "A color"] },
        ],
        "Emotion": [
            { name: "Happiness", type: "range", min: 0, max: 10, modes: { "is": "is", "is between": "is between", "is below": "is below", "is above": "is above" }, prefixes: ["Happiness", "The happiness level"] },
            { name: "Sadness", type: "range", min: 0, max: 10, modes: { "is": "is", "is between": "is between", "is below": "is below", "is above": "is above" }, prefixes: ["Sadness", "The sadness level"] },
            { name: "Anger", type: "range", min: 0, max: 10, modes: { "is": "is", "is between": "is between", "is below": "is below", "is above": "is above" }, prefixes: ["Anger", "The anger level"] },
        ],
        "Business": [
            { name: "Revenue", type: "number", unit: "USD", modes: { "is": "is", "is between": "is between", "is below": "is below", "is above": "is above" }, prefixes: ["The revenue", "Revenue"] },
            { name: "Product", type: "list", options: ["Software", "Hardware", "Service"], modes: { "is one of": "is" }, prefixes: ["The product", "A product"] },
            { name: "Customer Segment", type: "list", options: ["B2B", "B2C", "Government"], modes: { "is one of": "is" }, prefixes: ["The customer segment", "A customer segment"] },
        ],
        "Time": [
            { name: "Time", type: "time", modes: { "is": "is at", "is between": "is between", "is before": "is before", "is after": "is after" }, editor: 'calendar', prefixes: ["The time", "A time"] }
        ],
        "Misc": [
            { name: "Generic List", type: "list", options: [], modes: { "is one of": "is" }, prefixes: ["","A"]},
        ]
    };

    // --- Utility Functions ---
    function createElement(tagName, attributes = {}, textContent = '') {
        const element = document.createElement(tagName);
        Object.entries(attributes).forEach(([key, value]) => element.setAttribute(key, value));
        if (textContent) element.textContent = textContent;
        return element;
    }

    // --- Base Classes ---
    class UIComponent {
        constructor() {
            this.element = null;
        }

        getElement() {
            return this.element;
        }
    }

    class InputComponent extends UIComponent {
        constructor(value, onChange) {
            super();
            this.value = value;
            this.onChange = onChange;
        }
    }

    // --- Specific Input Components ---

    class NumberInput extends InputComponent {
        constructor(value, onChange, placeholder = "") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }

        createInput() {
            return createElement('input', {
                type: 'number',
                value: this.value ?? '',
                placeholder: this.placeholder,
                oninput: this.handleInput.bind(this)
            });
        }

        handleInput(event) {
            const parsedValue = parseFloat(event.target.value || 0);
            if (!isNaN(parsedValue)) {
                this.onChange(parsedValue);
            }
        }
    }

    class TextInput extends InputComponent {
        constructor(value, onChange, placeholder = "") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }

        createInput() {
            return createElement('input', {
                type: 'text',
                value: this.value ?? '',
                placeholder: this.placeholder,
                oninput: (event) => this.onChange(event.target.value)
            });
        }
    }

    class ListInput extends InputComponent {
        constructor(options, value, onChange) {
            super(value, onChange);
            this.options = options;
            this.element = this.createSelect();
        }

        createSelect() {
            const select = createElement('select');
            this.options.forEach(option => select.appendChild(new Option(option, option)));
            select.value = this.value || this.options[0];
            select.addEventListener('change', () => this.onChange(select.value));
            return select;
        }
    }

    class LocationInput extends InputComponent {
        constructor(value, onChange, placeholder = "Lat, Lng") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }

        createInput() {
            const input = createElement('input', {
                type: 'text',
                value: this.value ? `${this.value.lat}, ${this.value.lng}` : '',
                placeholder: this.placeholder,
                oninput: this.handleInput.bind(this)
            });
            return input;
        }

        handleInput(event) {
            const [lat, lng] = event.target.value.split(',').map(v => parseFloat(v.trim()));
            this.onChange(!isNaN(lat) && !isNaN(lng) ? { lat, lng } : null);
        }
    }

    class ColorInput extends InputComponent {
        constructor(value, onChange) {
            super(value, onChange);
            this.element = this.createInput();
        }

        createInput() {
            return createElement('input', {
                type: 'color',
                value: this.value || '#000000',
                oninput: (event) => this.onChange(event.target.value)
            });
        }
    }

    class ColorPreview extends UIComponent {
        constructor(color) {
            super();
            this.element = createElement('span', { class: 'color-preview' });
            this.setColor(color);
        }

        setColor(color) {
            this.element.style.backgroundColor = color;
        }
    }

    class UnitLabel extends UIComponent {
        constructor(unit) {
            super();
            this.element = createElement('span', { class: 'unit-label' }, ` ${unit || ''}`);
        }
    }

    class RemoveTagButton extends UIComponent {
        constructor(onRemove) {
            super();
            this.onRemove = onRemove;
            this.element = this.createButton();
        }

        createButton() {
            return createElement('span', {
                class: 'remove-tag',
                onclick: (event) => {
                    this.onRemove();
                    event.stopPropagation();
                }
            }, 'x');
        }
    }

    // --- Tag Class ---

    class Tag extends UIComponent {
        constructor(tagData) {
            super();
            this.tagData = { ...tagData, mode: tagData.mode || Object.keys(tagData.modes)[0] };
            this.initializeValues();
            this.inputComponents = {};
            this.element = this.createElement();
        }

        initializeValues() {
            if (['number', 'range'].includes(this.data.type)) {
                this.data.value = this.data.value ?? 0;
            } else if (this.data.type === 'list') {
                this.data.value = this.data.value ?? this.data.options[0];
            } else if (this.data.type === 'color') {
                this.data.value = this.data.value ?? '#000000';
            }
        }

        createElement() {
            const tagElement = createElement('span', {
                class: `tag ${this.isConditional() ? 'conditional' : ''}`,
                'data-tag-data': JSON.stringify(this.data)
            });

            tagElement.appendChild(document.createTextNode(this.data.name + " "));
            tagElement.appendChild(this.createModeSelect());
            this.rebuildInputs(tagElement);
            return tagElement;
        }

        createModeSelect() {
            const select = createElement('select');
            for (const modeKey in this.data.modes) {
                select.appendChild(new Option(this.data.modes[modeKey], modeKey));
            }
            select.value = this.data.mode;
            select.addEventListener('change', () => {
                this.data.mode = select.value;
                this.adjustValuesForMode();
                this.rebuildInputs(this.element);
                this.updateTagData();
            });
            return select;
        }

        isConditional() {
            return this.data.mode !== 'is' && this.data.mode?.startsWith('is');
        }

        adjustValuesForMode() {
            if (this.data.mode === "is between") {
                this.data.min = this.data.min ?? 0;
                this.data.max = this.data.max ?? 0;
            } else if (this.data.mode === "is below") {
                this.data.max = this.data.max ?? 0;
                this.data.min = null;
            } else if (this.data.mode === "is above") {
                this.data.min = this.data.min ?? 0;
                this.data.max = null;
            } else {
                this.data.value = this.data.value ?? (this.data.type === "list" ? this.data.options[0] : 0);
            }
        }

        rebuildInputs(tagElement) {
            tagElement.querySelectorAll('input, select:not(:first-of-type), .color-preview, .unit-label')
                .forEach(el => el.remove());
            this.inputComponents = {};

            const removeTagButton = new RemoveTagButton(() => tagElement.remove());

            switch (this.data.type) {
                case 'number':
                    this.createNumberInputs(tagElement);
                    break;
                case 'list':
                    this.createListInput(tagElement);
                    break;
                case 'location':
                    this.createLocationInput(tagElement);
                    break;
                case 'color':
                    this.createColorInput(tagElement);
                    break;
                case 'time':
                    this.createTimeInputs(tagElement);
                    break;
                case 'range':
                    this.createRangeInputs(tagElement);
                    break;
            }

            tagElement.appendChild(removeTagButton.getElement());
        }

        createNumberInputs(tagElement) {
            const appendInput = (inputComponent, key) => {
                tagElement.appendChild(inputComponent.getElement());
                if (key) this.inputComponents[key] = inputComponent;
            };

            const createAndAppendNumberInput = (value, placeholder, key) => {
                appendInput(new NumberInput(value, (v) => {
                    this.data[key || 'value'] = v;
                    this.updateTagData();
                }, placeholder), key);
            };

            if (this.data.mode === 'is') {
                createAndAppendNumberInput(this.data.value, "", "value");
            } else if (this.data.mode === 'is between') {
                createAndAppendNumberInput(this.data.min, "Min", 'min');
                tagElement.appendChild(document.createTextNode(" and "));
                createAndAppendNumberInput(this.data.max, "Max", 'max');
            } else if (['is below', 'is above'].includes(this.data.mode)) {
                const key = this.data.mode === 'is below' ? 'max' : 'min';
                createAndAppendNumberInput(this.data[key], this.data.mode === 'is below' ? "Max" : "Min", key);
            }
            tagElement.appendChild(new UnitLabel(this.data.unit).getElement());
        }

        createListInput(tagElement) {
            const listInput = new ListInput(this.data.options, this.data.value, (v) => {
                this.data.value = v;
                this.updateTagData();
            });
            tagElement.appendChild(listInput.getElement());
            this.inputComponents.value = listInput;
        }

        createLocationInput(tagElement) {
            const locationInput = new LocationInput(this.data.value, (v) => {
                this.data.value = v;
                this.updateTagData();
            });
            tagElement.appendChild(locationInput.getElement());
            this.inputComponents.value = locationInput;
        }

        createColorInput(tagElement) {
            const colorInput = new ColorInput(this.data.value, (v) => {
                this.data.value = v;
                this.updateTagData();
            });
            tagElement.appendChild(colorInput.getElement());
            this.inputComponents.value = colorInput;

            const colorPreview = new ColorPreview(this.data.value);
            tagElement.appendChild(colorPreview.getElement());
        }

        createRangeInputs(tagElement) {
            this.createNumberInputs(tagElement);
        }

        createTimeInputs(tagElement) {
            const appendInput = (inputComponent, key) => {
                tagElement.appendChild(inputComponent.getElement());
                if (key) this.inputComponents[key] = inputComponent;
            };

            const createAndAppendTextInput = (value, placeholder, key) => {
                appendInput(new TextInput(value, (v) => {
                    this.data[key || 'value'] = v;
                    this.updateTagData();
                }, placeholder), key);
            };

            if (this.data.mode === 'is') {
                createAndAppendTextInput(this.data.value, "", 'value');
            } else if (this.data.mode === 'is between') {
                createAndAppendTextInput(this.data.min, "Start Time", 'min');
                tagElement.appendChild(document.createTextNode(" and "));
                createAndAppendTextInput(this.data.max, "End Time", 'max');
            } else if (['is before', 'is after'].includes(this.data.mode)) {
                const key = this.data.mode === 'is before' ? 'max' : 'min';
                createAndAppendTextInput(this.data[key], this.data.mode === 'is before' ? "Before" : "After", key);
            }
        }

        updateTagData() {
            this.element.dataset.tagData = JSON.stringify(this.data);
        }
    }
    // --- Suggestion Dropdown Class ---
    class SuggestionDropdown extends UIComponent {
        constructor() {
            super();
            this.element = createElement('div', { id: 'suggestion-dropdown' });
            this.hide(); // Initially hidden
            document.body.appendChild(this.element); // Append to body
            this.selectedIndex = -1; // Track selected suggestion
        }

        show(suggestions, x, y, onSelect) {
            this.element.innerHTML = ''; // Clear previous suggestions
            suggestions.forEach((suggestion, index) => {
                const suggestionElement = createElement('div', {
                    'data-index': index,
                    onclick: () => {
                        onSelect(suggestion);
                        this.hide();
                    }
                }, suggestion.displayText);

                this.element.appendChild(suggestionElement);

            });

            this.element.style.left = `${x}px`;
            this.element.style.top = `${y}px`;
            this.element.style.display = 'block';
            this.selectedIndex = -1; // Reset selection
            this.updateSelection(); // Ensure no selection initially
        }

        hide() {
            this.element.style.display = 'none';
        }

        moveSelection(direction) {
            const numSuggestions = this.element.children.length;
            if (numSuggestions === 0) return;

            this.selectedIndex += direction;
            if (this.selectedIndex < 0) {
                this.selectedIndex = numSuggestions - 1; // Wrap to bottom
            } else if (this.selectedIndex >= numSuggestions) {
                this.selectedIndex = 0; // Wrap to top
            }
            this.updateSelection();
        }
        updateSelection() {
            const children = this.element.children;
            for (let i = 0; i < children.length; i++) {
                children[i].style.backgroundColor = i === this.selectedIndex ? '#ddd' : 'transparent';
            }
        }
        getSelectedSuggestion() {
            if (this.selectedIndex >= 0 && this.selectedIndex < this.element.children.length) {
                return this.element.children[this.selectedIndex].textContent; //Return text content
            }
            return null;
        }
    }

    // --- Ontology Browser Class ---
    class OntologyBrowser extends UIComponent {
        constructor(ontology, onTagSelect) {
            super();
            this.ontology = ontology;
            this.onTagSelect = onTagSelect;
            this.element = this.createBrowser();
        }

        createBrowser() {
            const browser = createElement('div', { id: 'ontology-browser' });
            for (const category in this.ontology) {
                const categoryDiv = createElement('div', { class: 'category' }, category);
                this.ontology[category].forEach(tagData => {
                    const tagItem = createElement('div', {
                        class: 'tag-item',
                        onclick: () => this.onTagSelect(new Tag(tagData))
                    }, tagData.name);
                    categoryDiv.appendChild(tagItem);
                });
                browser.appendChild(categoryDiv);
            }
            return browser;
        }

        show() {
            this.element.style.display = 'block';
            const rect = showOntologyButton.getBoundingClientRect();
            this.element.style.top = `${rect.bottom + window.scrollY}px`;
            this.element.style.left = `${rect.left + window.scrollX}px`;
        }

        hide() {
            this.element.style.display = 'none';
        }
    }

    // --- Semantic Editor Class ---

    class SemanticEditor extends UIComponent {
        constructor(editorElement, ontology) {
            super();
            this.editor = editorElement;
            this.ontology = ontology;
            this.ontologyBrowser = new OntologyBrowser(this.ontology, this.insertTag.bind(this));
            document.body.appendChild(this.ontologyBrowser.getElement());
            this.suggestionDropdown = new SuggestionDropdown();
            this.setupEventListeners();
            this.suggestionTimeout = null;
            this.suggestionDelay = 250; // Debounce delay
            this.lastSuggestionText = ''; // Track last suggested text
        }
        insertTag(tag) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Replace the suggestion text with the tag
                if (this.lastSuggestionText) {
                    // Find start of word.
                    let start = range.startOffset;
                    let container = range.startContainer;
                    while(start > 0 && /\w/.test(container.textContent[start-1])){
                        start--;
                    }
                    range.setStart(range.startContainer, start);
                    range.deleteContents();
                    this.lastSuggestionText = ''; // Reset after insertion
                }

                range.insertNode(tag.getElement());
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                this.editor.appendChild(tag.getElement());
            }
        }

        serialize() {
            const clonedContent = this.editor.cloneNode(true);
            clonedContent.querySelectorAll('.tag').forEach(tagElement => {
                const tagData = JSON.parse(tagElement.dataset.tagData);
                tagElement.replaceWith(document.createTextNode(`[TAG:${JSON.stringify(tagData)}]`));
            });
            return clonedContent.textContent;
        }

        deserialize(text) {
            this.editor.innerHTML = '';
            const tagRegex = /\[TAG:(.*?)\]/g;
            let match;
            let lastIndex = 0;

            while ((match = tagRegex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    this.editor.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                }
                try {
                    const tagData = JSON.parse(match[1]);
                    const tag = new Tag(tagData);
                    this.editor.appendChild(tag.getElement());
                } catch (error) {
                    console.error("Error parsing tag data:", error);
                    this.editor.appendChild(document.createTextNode(match[0]));
                }
                lastIndex = tagRegex.lastIndex;
            }
            if (lastIndex < text.length) {
                this.editor.appendChild(document.createTextNode(text.substring(lastIndex)));
            }
        }

        setupEventListeners() {
            showOntologyButton.addEventListener('click', () => {
                const isVisible = this.ontologyBrowser.getElement().style.display !== 'none';
                isVisible ? this.ontologyBrowser.hide() : this.ontologyBrowser.show();
            });

            serializeButton.addEventListener('click', () => {
                serializationOutput.value = this.serialize();
            });

            serializationOutput.addEventListener('input', () => this.deserialize(serializationOutput.value));

            this.editor.addEventListener('input', this.handleInput.bind(this));
            this.editor.addEventListener('keydown', this.handleKeyDown.bind(this));
            this.editor.addEventListener('blur', () => { //Hide on blur.
                setTimeout(() => this.suggestionDropdown.hide(), 100);
            });
            document.addEventListener('click', (event) => {
                if (!this.editor.contains(event.target) && !this.ontologyBrowser.getElement().contains(event.target)) {
                    this.suggestionDropdown.hide();
                }
            });
        }
        handleInput() {
            if (this.suggestionTimeout) clearTimeout(this.suggestionTimeout);
            this.suggestionTimeout = setTimeout(() => this.showSuggestions(), this.suggestionDelay);
        }

        handleKeyDown(event) {
            if (this.suggestionDropdown.element.style.display === 'block') {
                switch (event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        this.suggestionDropdown.moveSelection(1);
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        this.suggestionDropdown.moveSelection(-1);
                        break;
                    case 'Enter':
                        event.preventDefault();
                        const selectedSuggestionText = this.suggestionDropdown.getSelectedSuggestion();
                        if (selectedSuggestionText) {
                            const suggestion = this.findSuggestion(selectedSuggestionText);
                            if (suggestion) {
                                this.insertTag(new Tag(suggestion.tagData));
                            }
                        }
                        this.suggestionDropdown.hide();
                        break;
                    case 'Escape':
                        event.preventDefault();
                        this.suggestionDropdown.hide();
                        break;
                    default: //Important - retrigger suggestions!
                        if (event.key.length === 1 || event.key === 'Backspace') {
                            this.handleInput(); // Show suggestions again
                        }
                }
            }
        }

        findSuggestion(text){
            for(const category in this.ontology){
                for(const tagData of this.ontology[category]){
                    if (tagData.name === text) {
                        return { displayText: tagData.name, tagData };
                    }
                }
            }
            return null;
        }

        showSuggestions() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            const textBeforeCursor = range.startContainer.textContent.substring(0, range.startOffset);
            const lastWord = textBeforeCursor.split(/\s+/).pop();

            if (!lastWord) {
                this.suggestionDropdown.hide();
                return;
            }
            this.lastSuggestionText = lastWord; // Store for replacement

            const suggestions = [];
            for (const category in this.ontology) {
                for (const tagData of this.ontology[category]) {
                    // Check prefixes for better suggestions
                    if (tagData.prefixes) {
                        for (const prefix of tagData.prefixes) {
                            const fullSuggestion = prefix + (prefix.endsWith(" ") ? "" : " ") + tagData.name;
                            // Check if suggestion matches, ignoring case
                            if (fullSuggestion.toLowerCase().startsWith(lastWord.toLowerCase())) {
                                suggestions.push({ displayText: fullSuggestion, tagData });
                                break; // Only add one suggestion per tag, even with multiple prefixes
                            }
                        }
                    } else if (tagData.name.toLowerCase().startsWith(lastWord.toLowerCase())) {
                        // Fallback to just the name
                        suggestions.push({ displayText: tagData.name, tagData });
                    }
                }
            }

            if (suggestions.length > 0) {
                const rect = range.getBoundingClientRect();
                this.suggestionDropdown.show(
                    suggestions,
                    rect.left + window.scrollX,
                    rect.bottom + window.scrollY,
                    (selectedSuggestion) => {
                        this.insertTag(new Tag(selectedSuggestion.tagData));
                    }
                );
            } else {
                this.suggestionDropdown.hide();
            }
        }
    }

    const semanticEditor = new SemanticEditor(editor, ontology);
</script>

</body>
</html>