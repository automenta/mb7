<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Semantic Text Editor</title>
    <style>
        /* CSS Variables for light and dark themes */
        :root {
            --primary-font: 'Segoe UI', sans-serif;
            --bg-color: #ffffff;
            --text-color: #333333;
            --tag-bg: #e0f7fa;
            --tag-border: #80deea;
            --tag-conditional-bg: #fff3e0;
            --tag-conditional-border: #ffcc80;
            --toolbar-bg: #f5f5f5;
            --button-bg: #ffffff;
            --button-border: #ccc;
            --button-hover-bg: #eaeaea;
            --editor-border: #ccc;
            --dropdown-bg: #ffffff;
            --dropdown-border: #ccc;
            --dropdown-hover-bg: #eee;
        }
        [data-theme="dark"] {
            --bg-color: #1e1e1e;
            --text-color: #cccccc;
            --tag-bg: #333333;
            --tag-border: #555555;
            --tag-conditional-bg: #444444;
            --tag-conditional-border: #666666;
            --toolbar-bg: #2e2e2e;
            --button-bg: #3e3e3e;
            --button-border: #555555;
            --button-hover-bg: #4e4e4e;
            --editor-border: #555555;
            --dropdown-bg: #3e3e3e;
            --dropdown-border: #555555;
            --dropdown-hover-bg: #4e4e4e;
        }
        body {
            margin: 0;
            font-family: var(--primary-font);
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 960px;
            margin: auto;
            padding: 20px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--toolbar-bg);
            padding: 10px 20px;
            border-bottom: 1px solid var(--editor-border);
        }
        header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        #toolbar {
            display: flex;
            gap: 10px;
        }
        #toolbar button {
            background-color: var(--button-bg);
            border: 1px solid var(--button-border);
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
        }
        #toolbar button:hover {
            background-color: var(--button-hover-bg);
        }
        #editor {
            border: 1px solid var(--editor-border);
            min-height: 250px;
            padding: 15px;
            border-radius: 4px;
            background-color: var(--button-bg);
            white-space: pre-wrap;
            overflow-y: auto;
        }
        .tag {
            background-color: var(--tag-bg);
            border: 1px solid var(--tag-border);
            border-radius: 4px;
            padding: 2px 5px;
            margin: 0 2px;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
        }
        .tag.conditional {
            background-color: var(--tag-conditional-bg);
            border-color: var(--tag-conditional-border);
        }
        .tag input,
        .tag select {
            border: none;
            background: transparent;
            font-size: inherit;
            padding: 0;
            margin: 0;
            width: auto;
            outline: none;
        }
        .tag select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 0 2px;
            cursor: pointer;
        }
        .tag .remove-tag {
            margin-left: 5px;
            cursor: pointer;
            color: var(--text-color);
            font-size: 0.8em;
        }
        .color-preview {
            width: 1em;
            height: 1em;
            display: inline-block;
            border: 1px solid var(--editor-border);
            margin-left: 2px;
        }
        /* Ontology Browser */
        #ontology-browser {
            border: 1px solid var(--editor-border);
            padding: 10px;
            width: 260px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            position: absolute;
            background-color: var(--dropdown-bg);
            z-index: 50;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #ontology-browser .category {
            font-weight: bold;
            margin-top: 1em;
        }
        #ontology-browser .tag-item {
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
        }
        #ontology-browser .tag-item:hover {
            background-color: var(--dropdown-hover-bg);
        }
        /* Suggestion Dropdown */
        #suggestion-dropdown {
            position: absolute;
            display: none;
            background-color: var(--dropdown-bg);
            border: 1px solid var(--dropdown-border);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #suggestion-dropdown div {
            padding: 5px 10px;
            cursor: pointer;
        }
        #suggestion-dropdown div:hover,
        #suggestion-dropdown .selected {
            background-color: var(--dropdown-hover-bg);
        }
        /* Serialization Modal */
        #serialization-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--button-bg);
            border: 1px solid var(--editor-border);
            padding: 20px;
            display: none;
            z-index: 200;
            border-radius: 4px;
            width: 80%;
            max-width: 500px;
        }
        #serialization-modal textarea {
            width: 100%;
            height: 150px;
            resize: vertical;
            margin-top: 10px;
        }
        #serialization-modal button {
            margin-top: 10px;
            float: right;
        }
        /* Responsive adjustments */
        @media (max-width: 600px) {
            header, .container {
                padding: 10px;
            }
            #ontology-browser {
                width: 220px;
            }
        }
    </style>
</head>
<body data-theme="light">
<header>
    <h1>Advanced Semantic Editor</h1>
    <div id="toolbar">
        <button id="focus-editor" title="Focus Editor">Focus</button>
        <button id="toggle-ontology" title="Toggle Ontology Browser">Ontology</button>
        <button id="serialize" title="Serialize Content">Serialize</button>
        <button id="clear-editor" title="Clear Editor">Clear</button>
        <button id="save-editor" title="Save to Local Storage">Save</button>
        <button id="toggle-theme" title="Toggle Dark/Light Mode">Dark Mode</button>
    </div>
</header>
<div class="container">
    <div id="editor" contenteditable="true" aria-label="Semantic text editor">
        Type your text here. Use ontology tags by typing keywords or opening the Ontology Browser.
    </div>
</div>
<div id="ontology-browser" aria-label="Ontology Browser"></div>
<div id="suggestion-dropdown" aria-label="Suggestions"></div>
<div id="serialization-modal" aria-modal="true">
    <h2>Serialized Content</h2>
    <textarea id="serialization-output" readonly></textarea>
    <button id="copy-serialization">Copy</button>
    <button id="close-serialization">Close</button>
</div>
<script>
    // Wrap all code in an IIFE for encapsulation
    (function(){
        'use strict';

        /**************************************
         * Data Model: Ontology
         **************************************/
        const ontology = {
            Physical: [
                { name: "Mass", type: "number", unit: "kg", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
                { name: "Length", type: "number", unit: "m", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
                { name: "Temperature", type: "number", unit: "°C", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
                { name: "Location", type: "location", modes: { is: "is at", "is within": "is within" }, editor: "map" },
                { name: "Color", type: "color", modes: { is: "is" } }
            ],
            Emotion: [
                { name: "Happiness", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
                { name: "Sadness", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
                { name: "Anger", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } }
            ],
            Business: [
                { name: "Revenue", type: "number", unit: "USD", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
                { name: "Product", type: "list", options: ["Software", "Hardware", "Service"], modes: { "is one of": "is" } },
                { name: "Customer Segment", type: "list", options: ["B2B", "B2C", "Government"], modes: { "is one of": "is" } }
            ],
            Time: [
                { name: "Time", type: "time", modes: { is: "is at", "is between": "is between", "is before": "is before", "is after": "is after" }, editor: "calendar" }
            ],
            Misc: [
                { name: "Generic List", type: "list", options: [], modes: { "is one of": "is" } }
            ]
        };

        /**************************************
         * Utility Functions
         **************************************/
        const createElement = (tag, attrs = {}, text = "") => {
            const el = document.createElement(tag);
            Object.entries(attrs).forEach(([key, value]) => {
                if (key.startsWith("on") && typeof value === "function") {
                    el.addEventListener(key.substring(2), value);
                } else {
                    el.setAttribute(key, value);
                }
            });
            if (text) el.textContent = text;
            return el;
        };

        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };

        /**************************************
         * UI Component Base Class
         **************************************/
        class UIComponent {
            constructor() { this.element = null; }
            getElement() { return this.element; }
        }

        /**************************************
         * Input Components
         **************************************/
        class InputComponent extends UIComponent {
            constructor(value, onChange) {
                super();
                this.value = value;
                this.onChange = onChange;
            }
        }

        class NumberInput extends InputComponent {
            constructor(value, onChange, placeholder = "") {
                super(value, onChange);
                this.placeholder = placeholder;
                this.element = this.createInput();
            }
            createInput() {
                const input = createElement("input", { type: "number", placeholder: this.placeholder });
                input.value = this.value ?? "";
                input.addEventListener("input", (e) => {
                    const parsed = parseFloat(e.target.value || 0);
                    if (!isNaN(parsed)) {
                        this.onChange(parsed);
                    }
                });
                return input;
            }
        }

        class TextInput extends InputComponent {
            constructor(value, onChange, placeholder = "") {
                super(value, onChange);
                this.placeholder = placeholder;
                this.element = this.createInput();
            }
            createInput() {
                const input = createElement("input", { type: "text", placeholder: this.placeholder });
                input.value = this.value ?? "";
                input.addEventListener("input", (e) => this.onChange(e.target.value));
                return input;
            }
        }

        class ListInput extends InputComponent {
            constructor(options, value, onChange) {
                super(value, onChange);
                this.options = options;
                this.element = this.createSelect();
            }
            createSelect() {
                const select = createElement("select");
                this.options.forEach(opt => select.appendChild(new Option(opt, opt)));
                select.value = this.value || this.options[0];
                select.addEventListener("change", () => this.onChange(select.value));
                return select;
            }
        }

        class LocationInput extends InputComponent {
            constructor(value, onChange, placeholder = "Lat, Lng") {
                super(value, onChange);
                this.placeholder = placeholder;
                this.element = this.createInput();
            }
            createInput() {
                const input = createElement("input", { type: "text", placeholder: this.placeholder });
                input.value = this.value ? `${this.value.lat}, ${this.value.lng}` : "";
                input.addEventListener("input", (e) => {
                    const parts = e.target.value.split(",");
                    const lat = parseFloat(parts[0]?.trim());
                    const lng = parseFloat(parts[1]?.trim());
                    this.onChange(!isNaN(lat) && !isNaN(lng) ? { lat, lng } : null);
                });
                return input;
            }
        }

        class ColorInput extends InputComponent {
            constructor(value, onChange) {
                super(value, onChange);
                this.element = this.createInput();
            }
            createInput() {
                const input = createElement("input", { type: "color" });
                input.value = this.value || "#000000";
                input.addEventListener("input", (e) => this.onChange(e.target.value));
                return input;
            }
        }

        class ColorPreview extends UIComponent {
            constructor(color) {
                super();
                this.element = createElement("span", { class: "color-preview" });
                this.setColor(color);
            }
            setColor(color) {
                this.element.style.backgroundColor = color;
            }
        }

        class UnitLabel extends UIComponent {
            constructor(unit) {
                super();
                this.element = createElement("span", { class: "unit-label" }, ` ${unit || ""}`);
            }
        }

        class RemoveTagButton extends UIComponent {
            constructor(onRemove) {
                super();
                this.onRemove = onRemove;
                this.element = createElement("span", { class: "remove-tag", title: "Remove tag" }, "×");
                this.element.addEventListener("click", (e) => {
                    e.stopPropagation();
                    onRemove();
                });
            }
        }

        /**************************************
         * Tag Input Controls
         **************************************/
        class TagInputControl extends UIComponent {
            constructor(tag) {
                super();
                this.tag = tag;
            }
            getElement() {
                throw new Error("Abstract method getElement() must be implemented");
            }
        }

        class NumericTagInputControl extends TagInputControl {
            getElement() {
                const frag = document.createDocumentFragment();
                const mode = this.tag.data.mode;
                const update = () => this.tag.updateTagData();
                const createNumInput = (key, placeholder) => {
                    const input = new NumberInput(this.tag.data[key], (v) => {
                        this.tag.data[key] = v;
                        update();
                    }, placeholder);
                    return input.getElement();
                };
                if (mode === "is") {
                    frag.appendChild(createNumInput("value", ""));
                } else if (mode === "is between") {
                    frag.appendChild(createNumInput("min", "Min"));
                    frag.appendChild(document.createTextNode(" and "));
                    frag.appendChild(createNumInput("max", "Max"));
                } else if (mode === "is below" || mode === "is above") {
                    const key = mode === "is below" ? "max" : "min";
                    frag.appendChild(createNumInput(key, mode === "is below" ? "Max" : "Min"));
                }
                frag.appendChild(new UnitLabel(this.tag.data.unit).getElement());
                return frag;
            }
        }

        class ListTagInputControl extends TagInputControl {
            getElement() {
                return new ListInput(this.tag.data.options, this.tag.data.value, (v) => {
                    this.tag.data.value = v;
                    this.tag.updateTagData();
                }).getElement();
            }
        }

        class LocationTagInputControl extends TagInputControl {
            getElement() {
                return new LocationInput(this.tag.data.value, (v) => {
                    this.tag.data.value = v;
                    this.tag.updateTagData();
                }).getElement();
            }
        }

        class ColorTagInputControl extends TagInputControl {
            getElement() {
                const frag = document.createDocumentFragment();
                const colorInput = new ColorInput(this.tag.data.value, (v) => {
                    this.tag.data.value = v;
                    this.tag.updateTagData();
                    colorPreview.setColor(v);
                });
                const colorPreview = new ColorPreview(this.tag.data.value);
                frag.appendChild(colorInput.getElement());
                frag.appendChild(colorPreview.getElement());
                return frag;
            }
        }

        class TimeTagInputControl extends TagInputControl {
            getElement() {
                const frag = document.createDocumentFragment();
                const mode = this.tag.data.mode;
                const update = () => this.tag.updateTagData();
                const createTextInput = (key, placeholder) => {
                    const input = new TextInput(this.tag.data[key], (v) => { this.tag.data[key] = v; update(); }, placeholder);
                    return input.getElement();
                };
                if (mode === "is") {
                    frag.appendChild(createTextInput("value", ""));
                } else if (mode === "is between") {
                    frag.appendChild(createTextInput("min", "Start Time"));
                    frag.appendChild(document.createTextNode(" and "));
                    frag.appendChild(createTextInput("max", "End Time"));
                } else if (mode === "is before" || mode === "is after") {
                    const key = mode === "is before" ? "max" : "min";
                    frag.appendChild(createTextInput(key, mode === "is before" ? "Before" : "After"));
                }
                return frag;
            }
        }

        /**************************************
         * Tag Component
         **************************************/
        class Tag extends UIComponent {
            constructor(tagData) {
                super();
                this.data = { ...tagData, mode: tagData.mode || Object.keys(tagData.modes)[0] };
                this.initializeDefaults();
                this.element = this.createElement();
            }
            initializeDefaults() {
                if (["number", "range"].includes(this.data.type)) {
                    this.data.value = this.data.value ?? 0;
                } else if (this.data.type === "list") {
                    this.data.value = this.data.value ?? (this.data.options?.[0] || "");
                } else if (this.data.type === "color") {
                    this.data.value = this.data.value ?? "#000000";
                }
            }
            createElement() {
                const tagEl = createElement("span", { class: `tag ${this.isConditional() ? "conditional" : ""}`, contenteditable: "false" });
                tagEl.appendChild(document.createTextNode(`${this.data.name} `));
                tagEl.appendChild(this.createModeSelect());
                this.rebuildInputs(tagEl);
                return tagEl;
            }
            createModeSelect() {
                const select = createElement("select");
                for (const mode in this.data.modes) {
                    select.appendChild(new Option(this.data.modes[mode], mode));
                }
                select.value = this.data.mode;
                select.addEventListener("change", () => {
                    this.data.mode = select.value;
                    this.adjustValuesForMode();
                    this.rebuildInputs(this.element);
                    this.updateTagData();
                });
                return select;
            }
            isConditional() {
                return this.data.mode !== "is" && String(this.data.mode).startsWith("is");
            }
            adjustValuesForMode() {
                if (this.data.mode === "is between") {
                    this.data.min = this.data.min ?? 0;
                    this.data.max = this.data.max ?? 0;
                } else if (this.data.mode === "is below") {
                    this.data.max = this.data.max ?? 0;
                    this.data.min = null;
                } else if (this.data.mode === "is above") {
                    this.data.min = this.data.min ?? 0;
                    this.data.max = null;
                } else {
                    this.data.value = this.data.value ?? (this.data.type === "list" ? this.data.options[0] : 0);
                }
            }
            rebuildInputs(tagEl) {
                // Remove previous dynamic inputs
                tagEl.querySelectorAll("input, select:not(:first-of-type), .color-preview, .unit-label").forEach(el => el.remove());
                let control;
                switch (this.data.type) {
                    case "number":
                    case "range":
                        control = new NumericTagInputControl(this);
                        break;
                    case "list":
                        control = new ListTagInputControl(this);
                        break;
                    case "location":
                        control = new LocationTagInputControl(this);
                        break;
                    case "color":
                        control = new ColorTagInputControl(this);
                        break;
                    case "time":
                        control = new TimeTagInputControl(this);
                        break;
                }
                if (control) tagEl.appendChild(control.getElement());
                tagEl.appendChild(new RemoveTagButton(() => tagEl.remove()).getElement());
            }
            updateTagData() {
                this.element.dataset.tagData = JSON.stringify(this.data);
            }
        }

        /**************************************
         * Suggestion Dropdown Component
         **************************************/
        class SuggestionDropdown extends UIComponent {
            constructor() {
                super();
                this.element = document.getElementById("suggestion-dropdown");
                this.hide();
                this.selectedIndex = -1;
            }
            show(suggestions, x, y, onSelect) {
                this.element.innerHTML = "";
                suggestions.forEach((sugg, i) => {
                    const suggEl = createElement("div", {}, sugg.displayText);
                    suggEl.dataset.index = i;
                    suggEl.addEventListener("click", () => { onSelect(sugg); this.hide(); });
                    this.element.appendChild(suggEl);
                });
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
                this.element.style.display = "block";
                this.selectedIndex = -1;
                this.updateSelection();
            }
            hide() {
                this.element.style.display = "none";
            }
            moveSelection(dir) {
                const count = this.element.children.length;
                if (!count) return;
                this.selectedIndex = (this.selectedIndex + dir + count) % count;
                this.updateSelection();
            }
            updateSelection() {
                Array.from(this.element.children).forEach((child, i) => {
                    child.classList.toggle("selected", i === this.selectedIndex);
                });
            }
            getSelectedSuggestion() {
                if (this.selectedIndex >= 0 && this.selectedIndex < this.element.children.length) {
                    const child = this.element.children[this.selectedIndex];
                    return { displayText: child.textContent, tagData: this.findTagData(child.textContent) };
                }
                return null;
            }
            findTagData(name) {
                for (const cat in ontology) {
                    for (const tagData of ontology[cat]) {
                        if (tagData.name === name) return tagData;
                    }
                }
                return null;
            }
        }

        /**************************************
         * Ontology Browser Component
         **************************************/
        class OntologyBrowser extends UIComponent {
            constructor(ontology, onTagSelect) {
                super();
                this.ontology = ontology;
                this.onTagSelect = onTagSelect;
                this.element = this.createBrowser();
            }
            createBrowser() {
                const browser = document.getElementById("ontology-browser");
                browser.innerHTML = "";
                for (const category in this.ontology) {
                    const catDiv = createElement("div", { class: "category" }, category);
                    this.ontology[category].forEach(tagData => {
                        const tagItem = createElement("div", { class: "tag-item" }, tagData.name);
                        tagItem.addEventListener("click", () => {
                            this.onTagSelect(new Tag(tagData));
                            this.hide();
                        });
                        catDiv.appendChild(tagItem);
                    });
                    browser.appendChild(catDiv);
                }
                return browser;
            }
            show(buttonRect) {
                this.element.style.display = "block";
                this.element.style.top = `${buttonRect.bottom + window.scrollY}px`;
                this.element.style.left = `${buttonRect.left + window.scrollX}px`;
            }
            hide() {
                this.element.style.display = "none";
            }
        }

        /**************************************
         * Semantic Editor Component
         **************************************/
        class SemanticEditor extends UIComponent {
            constructor(editorEl, ontology) {
                super();
                this.editor = editorEl;
                this.ontology = ontology;
                this.ontologyBrowser = new OntologyBrowser(this.ontology, this.insertTagFromOntology.bind(this));
                this.suggestionDropdown = new SuggestionDropdown();
                this.setupEventListeners();
                this.loadFromStorage();
            }
            insertTagFromOntology(tag) {
                this.insertTagAtSelection(tag);
            }
            insertTagAtSelection(tag) {
                const sel = window.getSelection();
                if (sel.rangeCount) {
                    const range = sel.getRangeAt(0);
                    range.deleteContents();
                    range.insertNode(tag.getElement());
                    range.collapse(false);
                    sel.removeAllRanges();
                    sel.addRange(range);
                } else {
                    this.editor.appendChild(tag.getElement());
                }
            }
            insertTagFromSuggestion(sugg) {
                const tagData = sugg.tagData;
                if (tagData) {
                    this.insertTagAtSelection(new Tag(tagData));
                }
            }
            serialize() {
                const clone = this.editor.cloneNode(true);
                clone.querySelectorAll(".tag").forEach(tagEl => {
                    const data = JSON.parse(tagEl.dataset.tagData);
                    tagEl.replaceWith(document.createTextNode(`[TAG:${JSON.stringify(data)}]`));
                });
                return clone.textContent;
            }
            deserialize(text) {
                this.editor.innerHTML = "";
                const tagRegex = /\[TAG:(.*?)\]/g;
                let lastIndex = 0, match;
                while ((match = tagRegex.exec(text)) !== null) {
                    if (match.index > lastIndex) {
                        this.editor.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                    }
                    try {
                        const data = JSON.parse(match[1]);
                        this.editor.appendChild(new Tag(data).getElement());
                    } catch (e) {
                        console.error("Error parsing tag:", e);
                        this.editor.appendChild(document.createTextNode(match[0]));
                    }
                    lastIndex = tagRegex.lastIndex;
                }
                if (lastIndex < text.length) {
                    this.editor.appendChild(document.createTextNode(text.substring(lastIndex)));
                }
            }
            saveToStorage() {
                localStorage.setItem("semanticEditorContent", this.serialize());
            }
            loadFromStorage() {
                const saved = localStorage.getItem("semanticEditorContent");
                if (saved) {
                    this.deserialize(saved);
                }
            }
            clear() {
                this.editor.innerHTML = "";
            }
            setupEventListeners() {
                // Editor input: show suggestions and auto-save on blur.
                this.editor.addEventListener("input", debounce(() => this.showSuggestions(), 300));
                this.editor.addEventListener("keydown", (e) => {
                    if (this.suggestionDropdown.element.style.display === "block") {
                        switch (e.key) {
                            case "ArrowDown":
                                e.preventDefault();
                                this.suggestionDropdown.moveSelection(1);
                                break;
                            case "ArrowUp":
                                e.preventDefault();
                                this.suggestionDropdown.moveSelection(-1);
                                break;
                            case "Enter":
                                e.preventDefault();
                                const suggestion = this.suggestionDropdown.getSelectedSuggestion();
                                if (suggestion) {
                                    this.insertTagFromSuggestion(suggestion);
                                }
                                this.suggestionDropdown.hide();
                                break;
                            case "Escape":
                                e.preventDefault();
                                this.suggestionDropdown.hide();
                                break;
                        }
                    }
                });
                document.addEventListener("click", (e) => {
                    if (!this.editor.contains(e.target) &&
                        !document.getElementById("ontology-browser").contains(e.target)) {
                        this.suggestionDropdown.hide();
                        this.ontologyBrowser.hide();
                    }
                });
                this.editor.addEventListener("blur", () => this.saveToStorage());
            }
            isInTag() {
                const sel = window.getSelection();
                return sel.rangeCount && sel.getRangeAt(0).startContainer.parentElement.closest(".tag") !== null;
            }
            showSuggestions() {
                if (this.isInTag()) { this.suggestionDropdown.hide(); return; }
                const sel = window.getSelection();
                if (!sel.rangeCount) return;
                const range = sel.getRangeAt(0);
                const textBefore = range.startContainer.textContent.substring(0, range.startOffset);
                const words = textBefore.split(/\s+/);
                const lastWord = words[words.length - 1];
                if (!lastWord) { this.suggestionDropdown.hide(); return; }
                const suggestions = [];
                for (const cat in this.ontology) {
                    for (const tagData of this.ontology[cat]) {
                        if (tagData.name.toLowerCase().startsWith(lastWord.toLowerCase())) {
                            suggestions.push({ displayText: tagData.name, tagData });
                        }
                    }
                }
                if (suggestions.length) {
                    const rect = range.getBoundingClientRect();
                    this.suggestionDropdown.show(suggestions, rect.left + window.scrollX, rect.bottom + window.scrollY, this.insertTagFromSuggestion.bind(this));
                } else {
                    this.suggestionDropdown.hide();
                }
            }
        }

        /**************************************
         * Initialization
         **************************************/
        document.addEventListener("DOMContentLoaded", () => {
            const editorEl = document.getElementById("editor");
            const semanticEditor = new SemanticEditor(editorEl, ontology);

            // Toolbar Buttons
            document.getElementById("focus-editor").addEventListener("click", () => editorEl.focus());
            document.getElementById("clear-editor").addEventListener("click", () => {
                if (confirm("Are you sure you want to clear the editor? This action cannot be undone.")) {
                    semanticEditor.clear();
                }
            });
            document.getElementById("serialize").addEventListener("click", () => {
                const serialized = semanticEditor.serialize();
                const modal = document.getElementById("serialization-modal");
                document.getElementById("serialization-output").value = serialized;
                modal.style.display = "block";
            });
            document.getElementById("copy-serialization").addEventListener("click", () => {
                const textarea = document.getElementById("serialization-output");
                textarea.select();
                document.execCommand("copy");
                alert("Copied to clipboard!");
            });
            document.getElementById("close-serialization").addEventListener("click", () => {
                document.getElementById("serialization-modal").style.display = "none";
            });
            document.getElementById("toggle-ontology").addEventListener("click", (e) => {
                const ontologyBrowserEl = document.getElementById("ontology-browser");
                if (ontologyBrowserEl.style.display === "block") {
                    ontologyBrowserEl.style.display = "none";
                } else {
                    const buttonRect = e.target.getBoundingClientRect();
                    semanticEditor.ontologyBrowser.show(buttonRect);
                }
            });
            document.getElementById("save-editor").addEventListener("click", () => {
                semanticEditor.saveToStorage();
                alert("Content saved!");
            });
            document.getElementById("toggle-theme").addEventListener("click", () => {
                const body = document.body;
                body.setAttribute("data-theme", body.getAttribute("data-theme") === "light" ? "dark" : "light");
            });
        });

    })();
</script>
</body>
</html>
