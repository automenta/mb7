<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Semantic Text Editor</title>
    <style>
        /* Basic Page & Editor Styles */
        body { font-family: sans-serif; margin: 20px; }
        h1 { margin-bottom: 10px; }
        #editor {
            border: 1px solid #ccc;
            padding: 10px;
            min-height: 200px;
            cursor: text;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        /* Tag Styles */
        .tag {
            background-color: #e0f7fa;
            border: 1px solid #80deea;
            border-radius: 4px;
            padding: 2px 5px;
            margin: 0 2px;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
        }
        .tag.conditional { background-color: #fff3e0; border-color: #ffcc80; }
        .tag input,
        .tag select {
            border: none;
            background: transparent;
            font-size: inherit;
            padding: 0;
            margin: 0;
            width: auto;
            outline: none;
        }
        .tag select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 0 2px;
            cursor: pointer;
        }
        .tag select::-ms-expand { display: none; }
        .tag .remove-tag {
            margin-left: 5px;
            cursor: pointer;
            color: #888;
            font-size: smaller;
        }
        .color-preview {
            width: 1em;
            height: 1em;
            display: inline-block;
            border: 1px solid #ccc;
            margin-left: 2px;
        }
        /* Ontology Browser & Serialization Output */
        #ontology-browser {
            border: 1px solid #ccc;
            padding: 10px;
            width: 250px;
            height: 300px;
            overflow-y: auto;
            display: none;
            position: absolute;
            background-color: white;
            z-index: 50;
        }
        #ontology-browser .category { font-weight: bold; margin-top: 1em; }
        #ontology-browser .tag-item { cursor: pointer; padding: 2px 5px; }
        #ontology-browser .tag-item:hover { background-color: #eee; }
        #serialization-output {
            width: 100%;
            height: 100px;
            margin-top: 10px;
        }
        /* Suggestion Dropdown Styles */
        #suggestion-dropdown {
            position: absolute;
            display: none;
            background-color: white;
            border: 1px solid #ccc;
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        #suggestion-dropdown div {
            padding: 5px;
            cursor: pointer;
        }
        #suggestion-dropdown div:hover { background-color: #eee; }
        /* Toolbar (Optional) */
        #toolbar { margin-bottom: 10px; }
        #toolbar button { padding: 5px 10px; margin-right: 5px; }
    </style>
</head>
<body>
<h1>Semantic Text Editor</h1>
<!-- Optional Toolbar -->
<div id="toolbar">
    <button id="focus-editor">Focus Editor</button>
</div>
<!-- Editable Area -->
<div id="editor" contenteditable="true">
    Type your free‑form text here. As you type, suggestions from the ontology appear.
</div>
<!-- Control Buttons -->
<button id="show-ontology">Show Ontology</button>
<button id="serialize">Serialize</button>
<!-- Floating Ontology Browser & Suggestion Dropdown -->
<div id="ontology-browser"></div>
<div id="suggestion-dropdown"></div>
<!-- Serialization Output -->
<textarea id="serialization-output" placeholder="Serialization will appear here"></textarea>

<script>
    /*****************************************************************
     * Data Model: Ontology
     *****************************************************************/
    const ontology = {
        Physical: [
            { name: "Mass", type: "number", unit: "kg", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Length", type: "number", unit: "m", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Temperature", type: "number", unit: "°C", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Location", type: "location", modes: { is: "is at", "is within": "is within" }, editor: "map" },
            { name: "Color", type: "color", modes: { is: "is" } }
        ],
        Emotion: [
            { name: "Happiness", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Sadness", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Anger", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } }
        ],
        Business: [
            { name: "Revenue", type: "number", unit: "USD", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
            { name: "Product", type: "list", options: ["Software", "Hardware", "Service"], modes: { "is one of": "is" } },
            { name: "Customer Segment", type: "list", options: ["B2B", "B2C", "Government"], modes: { "is one of": "is" } }
        ],
        Time: [
            { name: "Time", type: "time", modes: { is: "is at", "is between": "is between", "is before": "is before", "is after": "is after" }, editor: "calendar" }
        ],
        Misc: [
            { name: "Generic List", type: "list", options: [], modes: { "is one of": "is" } }
        ]
    };

    /*****************************************************************
     * Helper Function
     *****************************************************************/
    const createElement = (tag, attrs = {}, text = "") => {
        const el = document.createElement(tag);
        for (const [key, value] of Object.entries(attrs)) {
            if (key.startsWith("on") && typeof value === "function")
                el.addEventListener(key.substring(2), value);
            else
                el.setAttribute(key, value);
        }
        if (text) el.textContent = text;
        return el;
    };

    /*****************************************************************
     * Base Classes
     *****************************************************************/
    class UIComponent {
        constructor() { this.element = null; }
        getElement() { return this.element; }
    }

    class InputComponent extends UIComponent {
        constructor(value, onChange) {
            super();
            this.value = value;
            this.onChange = onChange;
        }
    }

    /*****************************************************************
     * Specific Input Components
     *****************************************************************/
    class NumberInput extends InputComponent {
        constructor(value, onChange, placeholder = "") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "number", placeholder: this.placeholder });
            input.value = this.value ?? "";
            input.addEventListener("input", (e) => {
                const parsed = parseFloat(e.target.value || 0);
                if (!isNaN(parsed)) this.onChange(parsed);
            });
            return input;
        }
    }

    class TextInput extends InputComponent {
        constructor(value, onChange, placeholder = "") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "text", placeholder: this.placeholder });
            input.value = this.value ?? "";
            input.addEventListener("input", (e) => this.onChange(e.target.value));
            return input;
        }
    }

    class ListInput extends InputComponent {
        constructor(options, value, onChange) {
            super(value, onChange);
            this.options = options;
            this.element = this.createSelect();
        }
        createSelect() {
            const select = createElement("select");
            this.options.forEach(opt => select.appendChild(new Option(opt, opt)));
            select.value = this.value || this.options[0];
            select.addEventListener("change", () => this.onChange(select.value));
            return select;
        }
    }

    class LocationInput extends InputComponent {
        constructor(value, onChange, placeholder = "Lat, Lng") {
            super(value, onChange);
            this.placeholder = placeholder;
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "text", placeholder: this.placeholder });
            input.value = this.value ? `${this.value.lat}, ${this.value.lng}` : "";
            input.addEventListener("input", (e) => {
                const parts = e.target.value.split(",");
                const lat = parseFloat(parts[0]?.trim());
                const lng = parseFloat(parts[1]?.trim());
                this.onChange(!isNaN(lat) && !isNaN(lng) ? { lat, lng } : null);
            });
            return input;
        }
    }

    class ColorInput extends InputComponent {
        constructor(value, onChange) {
            super(value, onChange);
            this.element = this.createInput();
        }
        createInput() {
            const input = createElement("input", { type: "color" });
            input.value = this.value || "#000000";
            input.addEventListener("input", (e) => this.onChange(e.target.value));
            return input;
        }
    }

    class ColorPreview extends UIComponent {
        constructor(color) {
            super();
            this.element = createElement("span", { class: "color-preview" });
            this.setColor(color);
        }
        setColor(color) { this.element.style.backgroundColor = color; }
    }

    class UnitLabel extends UIComponent {
        constructor(unit) { super(); this.element = createElement("span", { class: "unit-label" }, ` ${unit || ""}`); }
    }

    class RemoveTagButton extends UIComponent {
        constructor(onRemove) {
            super();
            this.onRemove = onRemove;
            this.element = createElement("span", { class: "remove-tag" }, "x");
            this.element.addEventListener("click", (e) => { e.stopPropagation(); onRemove(); });
        }
    }

    /*****************************************************************
     * Abstract Tag Input Control & Subclasses
     *****************************************************************/
    class TagInputControl extends UIComponent {
        constructor(tag) {
            super();
            this.tag = tag;
        }
        getElement() { throw new Error("Abstract method 'getElement' must be implemented"); }
    }

    class NumericTagInputControl extends TagInputControl {
        getElement() {
            const frag = document.createDocumentFragment();
            const mode = this.tag.tagData.mode;
            const update = () => this.tag.updateData();
            const createNumInput = (key, placeholder) => {
                const input = new NumberInput(this.tag.tagData[key], (v) => { this.tag.tagData[key] = v; update(); }, placeholder);
                return input.getElement();
            };
            if (mode === "is") {
                frag.appendChild(createNumInput("value", ""));
            } else if (mode === "is between") {
                frag.appendChild(createNumInput("min", "Min"));
                frag.appendChild(document.createTextNode(" and "));
                frag.appendChild(createNumInput("max", "Max"));
            } else if (mode === "is below" || mode === "is above") {
                const key = mode === "is below" ? "max" : "min";
                frag.appendChild(createNumInput(key, mode === "is below" ? "Max" : "Min"));
            }
            frag.appendChild(new UnitLabel(this.tag.tagData.unit).getElement());
            return frag;
        }
    }

    class ListTagInputControl extends TagInputControl {
        getElement() {
            return new ListInput(this.tag.tagData.options, this.tag.tagData.value, (v) => {
                this.tag.tagData.value = v;
                this.tag.updateData();
            }).getElement();
        }
    }

    class LocationTagInputControl extends TagInputControl {
        getElement() {
            return new LocationInput(this.tag.tagData.value, (v) => {
                this.tag.tagData.value = v;
                this.tag.updateData();
            }).getElement();
        }
    }

    class ColorTagInputControl extends TagInputControl {
        getElement() {
            const frag = document.createDocumentFragment();
            const colorInput = new ColorInput(this.tag.tagData.value, (v) => {
                this.tag.tagData.value = v;
                this.tag.updateData();
            });
            frag.appendChild(colorInput.getElement());
            frag.appendChild(new ColorPreview(this.tag.tagData.value).getElement());
            return frag;
        }
    }

    class TimeTagInputControl extends TagInputControl {
        getElement() {
            const frag = document.createDocumentFragment();
            const mode = this.tag.tagData.mode;
            const update = () => this.tag.updateData();
            const createTextInput = (key, placeholder) => {
                const input = new TextInput(this.tag.tagData[key], (v) => { this.tag.tagData[key] = v; update(); }, placeholder);
                return input.getElement();
            };
            if (mode === "is") {
                frag.appendChild(createTextInput("value", ""));
            } else if (mode === "is between") {
                frag.appendChild(createTextInput("min", "Start Time"));
                frag.appendChild(document.createTextNode(" and "));
                frag.appendChild(createTextInput("max", "End Time"));
            } else if (mode === "is before" || mode === "is after") {
                const key = mode === "is before" ? "max" : "min";
                frag.appendChild(createTextInput(key, mode === "is before" ? "Before" : "After"));
            }
            return frag;
        }
    }

    /*****************************************************************
     * Tag Class (Semantic Tag)
     *****************************************************************/
    class Tag extends UIComponent {
        constructor(tagData) {
            super();
            // Ensure default mode if none provided.
            this.data = { ...tagData, mode: tagData.mode || Object.keys(tagData.modes)[0] };
            this.initializeValues();
            this.element = this.createElement();
        }
        initializeValues() {
            if (["number", "range"].includes(this.data.type))
                this.data.value = this.data.value ?? 0;
            else if (this.data.type === "list")
                this.data.value = this.data.value ?? (this.data.options?.[0] || "");
            else if (this.data.type === "color")
                this.data.value = this.data.value ?? "#000000";
        }
        createElement() {
            const tagEl = createElement("span", { class: `tag ${this.isConditional() ? "conditional" : ""}`, contenteditable: "false" });
            tagEl.appendChild(document.createTextNode(`${this.data.name} `));
            tagEl.appendChild(this.createModeSelect());
            this.rebuildInputs(tagEl);
            return tagEl;
        }
        createModeSelect() {
            const select = createElement("select");
            for (const mode in this.data.modes) {
                select.appendChild(new Option(this.data.modes[mode], mode));
            }
            select.value = this.data.mode;
            select.addEventListener("change", () => {
                this.data.mode = select.value;
                this.adjustValuesForMode();
                this.rebuildInputs(this.element);
                this.updateData();
            });
            return select;
        }
        isConditional() { return this.data.mode !== "is" && String(this.data.mode).startsWith("is"); }
        adjustValuesForMode() {
            if (this.data.mode === "is between") { this.data.min = this.data.min ?? 0; this.data.max = this.data.max ?? 0; }
            else if (this.data.mode === "is below") { this.data.max = this.data.max ?? 0; this.data.min = null; }
            else if (this.data.mode === "is above") { this.data.min = this.data.min ?? 0; this.data.max = null; }
            else { this.data.value = this.data.value ?? (this.data.type === "list" ? this.data.options[0] : 0); }
        }
        rebuildInputs(tagEl) {
            tagEl.querySelectorAll("input, select:not(:first-of-type), .color-preview, .unit-label").forEach(el => el.remove());
            let control;
            switch (this.data.type) {
                case "number":
                case "range": control = new NumericTagInputControl(this); break;
                case "list": control = new ListTagInputControl(this); break;
                case "location": control = new LocationTagInputControl(this); break;
                case "color": control = new ColorTagInputControl(this); break;
                case "time": control = new TimeTagInputControl(this); break;
            }
            if (control) tagEl.appendChild(control.getElement());
            tagEl.appendChild(new RemoveTagButton(() => tagEl.remove()).getElement());
        }
        updateData() { this.element.dataset.tagData = JSON.stringify(this.data); }
    }

    /*****************************************************************
     * Suggestion Dropdown
     *****************************************************************/
    class SuggestionDropdown extends UIComponent {
        constructor() {
            super();
            this.element = createElement("div", { id: "suggestion-dropdown" });
            this.hide();
            document.body.appendChild(this.element);
            this.selectedIndex = -1;
        }
        show(suggestions, x, y, onSelect) {
            this.element.innerHTML = "";
            suggestions.forEach((sugg, i) => {
                const suggEl = createElement("div", {}, sugg.displayText);
                suggEl.dataset.index = i;
                suggEl.addEventListener("click", () => { onSelect(sugg); this.hide(); });
                this.element.appendChild(suggEl);
            });
            this.element.style.left = `${x}px`;
            this.element.style.top = `${y}px`;
            this.element.style.display = "block";
            this.selectedIndex = -1;
            this.updateSelection();
        }
        hide() { this.element.style.display = "none"; }
        moveSelection(dir) {
            const count = this.element.children.length;
            if (!count) return;
            this.selectedIndex = (this.selectedIndex + dir + count) % count;
            this.updateSelection();
        }
        updateSelection() {
            Array.from(this.element.children).forEach((child, i) =>
                child.style.backgroundColor = i === this.selectedIndex ? "#ddd" : "transparent"
            );
        }
        getSelectedSuggestion() {
            let i = this.selectedIndex;
            return i >= 0 && i < this.element.children.length
                ? this.element.children[i].textContent
                : null;
        }
    }

    /*****************************************************************
     * Ontology Browser
     *****************************************************************/
    class OntologyBrowser extends UIComponent {
        constructor(ontology, onTagSelect) {
            super();
            this.ontology = ontology;
            this.onTagSelect = onTagSelect;
            this.element = this.createBrowser();
        }
        createBrowser() {
            const browser = createElement("div", { id: "ontology-browser" });
            for (const category in this.ontology) {
                const catDiv = createElement("div", { class: "category" }, category);
                this.ontology[category].forEach(tag => {
                    const tagItem = createElement("div", { class: "tag-item" }, tag.name);
                    tagItem.addEventListener("click", () => this.onTagSelect(new Tag(tag)));
                    catDiv.appendChild(tagItem);
                });
                browser.appendChild(catDiv);
            }
            return browser;
        }
        show() {
            this.element.style.display = "block";
            const rect = showOntologyButton.getBoundingClientRect();
            this.element.style.top = `${rect.bottom + window.scrollY}px`;
            this.element.style.left = `${rect.left + window.scrollX}px`;
        }
        hide() { this.element.style.display = "none"; }
    }

    /*****************************************************************
     * Semantic Editor
     *****************************************************************/
    class SemanticEditor extends UIComponent {
        constructor(editorEl, ontology) {
            super();
            this.editor = editorEl;
            this.ontology = ontology;
            this.ontologyBrowser = new OntologyBrowser(this.ontology, this.insertTagFromOntology.bind(this));
            document.body.appendChild(this.ontologyBrowser.getElement());
            this.suggestionDropdown = new SuggestionDropdown();
            this.suggestionTimeout = null;
            this.setupEventListeners();
        }
        insertTagFromOntology(tag) {
            this.insertTagAtSelection(tag);
            this.ontologyBrowser.hide();
        }
        insertTagAtSelection(tag) {
            const sel = window.getSelection();
            if (sel.rangeCount) {
                const range = sel.getRangeAt(0);
                range.deleteContents();
                range.insertNode(tag.getElement());
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
            } else {
                this.editor.appendChild(tag.getElement());
            }
        }
        insertTagFromSuggestion(sugg) {
            const sel = window.getSelection();
            if (sel.rangeCount) {
                const range = sel.getRangeAt(0);
                if (range.startContainer.nodeType === Node.TEXT_NODE) {
                    range.startContainer.textContent = range.startContainer.textContent.replace(/(\s*\S+)$/, "");
                }
                this.insertTagAtSelection(new Tag(sugg.tagData));
            }
        }
        serialize() {
            const clone = this.editor.cloneNode(true);
            clone.querySelectorAll(".tag").forEach(tagEl => {
                const data = JSON.parse(tagEl.dataset.tagData);
                tagEl.replaceWith(document.createTextNode(`[TAG:${JSON.stringify(data)}]`));
            });
            return clone.textContent;
        }
        deserialize(text) {
            this.editor.innerHTML = "";
            const tagRegex = /\[TAG:(.*?)\]/g;
            let lastIndex = 0, match;
            while ((match = tagRegex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    this.editor.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                }
                try {
                    const data = JSON.parse(match[1]);
                    this.editor.appendChild(new Tag(data).getElement());
                } catch (e) {
                    console.error("Error parsing tag:", e);
                    this.editor.appendChild(document.createTextNode(match[0]));
                }
                lastIndex = tagRegex.lastIndex;
            }
            if (lastIndex < text.length) {
                this.editor.appendChild(document.createTextNode(text.substring(lastIndex)));
            }
        }
        setupEventListeners() {
            document.getElementById("focus-editor").addEventListener("click", () => this.editor.focus());
            showOntologyButton.addEventListener("click", () => {
                const visible = this.ontologyBrowser.getElement().style.display !== "none";
                visible ? this.ontologyBrowser.hide() : this.ontologyBrowser.show();
            });
            serializeButton.addEventListener("click", () => {
                serializationOutput.value = this.serialize();
            });
            serializationOutput.addEventListener("input", () => this.deserialize(serializationOutput.value));
            this.editor.addEventListener("input", () => {
                clearTimeout(this.suggestionTimeout);
                this.suggestionTimeout = setTimeout(() => this.showSuggestions(), 250);
            });
            this.editor.addEventListener("keydown", (e) => {
                if (this.suggestionDropdown.element.style.display === "block") {
                    switch (e.key) {
                        case "ArrowDown":
                            e.preventDefault();
                            this.suggestionDropdown.moveSelection(1);
                            break;
                        case "ArrowUp":
                            e.preventDefault();
                            this.suggestionDropdown.moveSelection(-1);
                            break;
                        case "Enter":
                            e.preventDefault();
                            const selText = this.suggestionDropdown.getSelectedSuggestion();
                            if (selText) {
                                const suggestion = this.findSuggestion(selText);
                                if (suggestion) this.insertTagFromSuggestion(suggestion);
                            }
                            this.suggestionDropdown.hide();
                            break;
                        case "Escape":
                            e.preventDefault();
                            this.suggestionDropdown.hide();
                            break;
                    }
                }
            });
            document.addEventListener("click", (e) => {
                if (!this.editor.contains(e.target) && !this.ontologyBrowser.getElement().contains(e.target)) {
                    this.suggestionDropdown.hide();
                }
            });
        }
        isInTag() {
            const sel = window.getSelection();
            return sel.rangeCount && sel.getRangeAt(0).startContainer.parentElement.closest(".tag") !== null;
        }
        showSuggestions() {
            if (this.isInTag()) { this.suggestionDropdown.hide(); return; }
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            const range = sel.getRangeAt(0);
            const textBefore = range.startContainer.textContent.substring(0, range.startOffset);
            const words = textBefore.split(/\s+/);
            const lastWord = words[words.length - 1];
            if (!lastWord) { this.suggestionDropdown.hide(); return; }
            const suggestions = [];
            for (const cat in this.ontology) {
                for (const tag of this.ontology[cat]) {
                    if (tag.name.toLowerCase().startsWith(lastWord.toLowerCase()))
                        suggestions.push({ displayText: tag.name, tagData: tag });
                }
            }
            if (suggestions.length) {
                const rect = range.getBoundingClientRect();
                this.suggestionDropdown.show(suggestions, rect.left + window.scrollX, rect.bottom + window.scrollY,
                    this.insertTagFromSuggestion.bind(this));
            } else {
                this.suggestionDropdown.hide();
            }
        }
        findSuggestion(text) {
            for (const cat in this.ontology) {
                for (const tagData of this.ontology[cat]) {
                    if (tagData.name === text) return { displayText: tagData.name, tagData };
                }
            }
            return null;
        }
    }

    /*****************************************************************
     * Initialization
     *****************************************************************/
    const editor = document.getElementById("editor");
    const showOntologyButton = document.getElementById("show-ontology");
    const serializeButton = document.getElementById("serialize");
    const serializationOutput = document.getElementById("serialization-output");
    const semanticEditor = new SemanticEditor(editor, ontology);
</script>
</body>
</html>
