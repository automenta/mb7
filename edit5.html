<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Semantic Text Editor – Revamped UX</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* CSS Variables for Theming */
    :root {
      --primary-color: #1976d2;
      --secondary-color: #dc004e;
      --background-color: #f5f5f5;
      --editor-bg: #fff;
      --tag-bg: #e3f2fd;
      --tag-border: #90caf9;
      --conditional-tag-bg: #fff3e0;
      --conditional-tag-border: #ffcc80;
      --text-color: #333;
      --border-radius: 8px;
      --transition-duration: 0.3s;
    }

    /* Reset & Global Styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      font-family: 'Roboto', sans-serif;
      color: var(--text-color);
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .container {
      max-width: 960px;
      margin: 0 auto;
    }

    /* Toolbar Styles */
    #toolbar {
      display: flex;
      justify-content: center;
      margin-bottom: 15px;
      gap: 10px;
    }
    #toolbar button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: background-color var(--transition-duration);
    }
    #toolbar button:hover {
      background-color: #1565c0;
    }
    #toolbar button#serialize {
      background-color: var(--secondary-color);
    }

    /* Editor Styles */
    #editor {
      background-color: var(--editor-bg);
      border: 1px solid #ccc;
      padding: 15px;
      min-height: 250px;
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      white-space: pre-wrap;
      overflow-y: auto;
    }

    /* Tag Styles */
    .tag {
      background-color: var(--tag-bg);
      border: 1px solid var(--tag-border);
      border-radius: 4px;
      padding: 4px 8px;
      margin: 0 3px;
      display: inline-flex;
      align-items: center;
      cursor: pointer;
      transition: background-color var(--transition-duration), border-color var(--transition-duration);
    }
    .tag.conditional {
      background-color: var(--conditional-tag-bg);
      border-color: var(--conditional-tag-border);
    }
    .tag input,
    .tag select {
      border: none;
      background: transparent;
      font-size: 1rem;
      padding: 2px;
      margin: 0;
      width: auto;
      outline: none;
    }
    .tag select {
      appearance: none;
      cursor: pointer;
    }
    .tag .remove-tag {
      margin-left: 8px;
      cursor: pointer;
      color: var(--secondary-color);
      font-size: 1.2rem;
    }
    .color-preview {
      width: 1.2em;
      height: 1.2em;
      display: inline-block;
      border: 1px solid #ccc;
      margin-left: 4px;
      border-radius: 50%;
    }

    /* Ontology Browser */
    #ontology-browser {
      border: 1px solid #ccc;
      padding: 15px;
      width: 280px;
      max-height: 400px;
      overflow-y: auto;
      background-color: #fff;
      position: fixed;
      top: 20%;
      right: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      border-radius: var(--border-radius);
      display: none;
      z-index: 50;
    }
    #ontology-browser .category {
      font-weight: 500;
      margin-top: 1em;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }
    #ontology-browser .tag-item {
      cursor: pointer;
      padding: 6px 8px;
      border-radius: 4px;
      transition: background-color var(--transition-duration);
    }
    #ontology-browser .tag-item:hover {
      background-color: #f0f0f0;
    }

    /* Suggestion Dropdown */
    #suggestion-dropdown {
      position: absolute;
      display: none;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      z-index: 100;
      max-height: 200px;
      overflow-y: auto;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }
    #suggestion-dropdown div {
      padding: 8px 12px;
      cursor: pointer;
      transition: background-color var(--transition-duration);
    }
    #suggestion-dropdown div:hover,
    #suggestion-dropdown .selected {
      background-color: #e0e0e0;
    }

    /* Serialization Output */
    #serialization-output {
      width: 100%;
      height: 120px;
      margin-top: 15px;
      border: 1px solid #ccc;
      border-radius: var(--border-radius);
      padding: 10px;
      resize: vertical;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Semantic Text Editor</h1>
  <!-- Toolbar -->
  <div id="toolbar">
    <button id="focus-editor" title="Focus Editor">Focus Editor</button>
    <button id="show-ontology" title="Browse Ontology">Browse Ontology</button>
    <button id="serialize" title="Serialize Content">Serialize</button>
  </div>
  <!-- Editable Area -->
  <div id="editor" contenteditable="true">
    Start typing your text here...
  </div>
  <!-- Serialization Output -->
  <textarea id="serialization-output" placeholder="Serialization will appear here"></textarea>
</div>

<!-- Floating Ontology Browser & Suggestion Dropdown -->
<div id="ontology-browser"></div>
<div id="suggestion-dropdown"></div>

<script>
  /*****************************************************************
   * Data Model: Ontology (Same as before)
   *****************************************************************/
  const ontology = {
    Physical: [
      { name: "Mass", type: "number", unit: "kg", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
      { name: "Length", type: "number", unit: "m", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
      { name: "Temperature", type: "number", unit: "°C", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
      { name: "Location", type: "location", modes: { is: "is at", "is within": "is within" }, editor: "map" },
      { name: "Color", type: "color", modes: { is: "is" } }
    ],
    Emotion: [
      { name: "Happiness", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
      { name: "Sadness", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
      { name: "Anger", type: "range", min: 0, max: 10, modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } }
    ],
    Business: [
      { name: "Revenue", type: "number", unit: "USD", modes: { is: "is", "is between": "is between", "is below": "is below", "is above": "is above" } },
      { name: "Product", type: "list", options: ["Software", "Hardware", "Service"], modes: { "is one of": "is" } },
      { name: "Customer Segment", type: "list", options: ["B2B", "B2C", "Government"], modes: { "is one of": "is" } }
    ],
    Time: [
      { name: "Time", type: "time", modes: { is: "is at", "is between": "is between", "is before": "is before", "is after": "is after" }, editor: "calendar" }
    ],
    Misc: [
      { name: "Generic List", type: "list", options: [], modes: { "is one of": "is" } }
    ]
  };

  /*****************************************************************
   * Helper Function
   *****************************************************************/
  const createElement = (tag, attrs = {}, text = "") => {
    const el = document.createElement(tag);
    for (const [key, value] of Object.entries(attrs)) {
      if (key.startsWith("on") && typeof value === "function")
        el.addEventListener(key.substring(2), value);
      else
        el.setAttribute(key, value);
    }
    if (text) el.textContent = text;
    return el;
  };

  /*****************************************************************
   * Base Classes
   *****************************************************************/
  class UIComponent {
    constructor() { this.element = null; }
    getElement() { return this.element; }
  }

  class InputComponent extends UIComponent {
    constructor(value, onChange) {
      super();
      this.value = value;
      this.onChange = onChange;
    }
  }

  /*****************************************************************
   * Specific Input Components
   *****************************************************************/
  class NumberInput extends InputComponent {
    constructor(value, onChange, placeholder = "") {
      super(value, onChange);
      this.placeholder = placeholder;
      this.element = this.createInput();
    }
    createInput() {
      const input = createElement("input", { type: "number", placeholder: this.placeholder });
      input.value = this.value ?? "";
      input.addEventListener("input", (e) => {
        const parsed = parseFloat(e.target.value || 0);
        if (!isNaN(parsed)) this.onChange(parsed);
      });
      return input;
    }
  }

  class TextInput extends InputComponent {
    constructor(value, onChange, placeholder = "") {
      super(value, onChange);
      this.placeholder = placeholder;
      this.element = this.createInput();
    }
    createInput() {
      const input = createElement("input", { type: "text", placeholder: this.placeholder });
      input.value = this.value ?? "";
      input.addEventListener("input", (e) => this.onChange(e.target.value));
      return input;
    }
  }

  class ListInput extends InputComponent {
    constructor(options, value, onChange) {
      super(value, onChange);
      this.options = options;
      this.element = this.createSelect();
    }
    createSelect() {
      const select = createElement("select");
      this.options.forEach(opt => select.appendChild(new Option(opt, opt)));
      select.value = this.value || this.options[0];
      select.addEventListener("change", () => this.onChange(select.value));
      return select;
    }
  }

  class LocationInput extends InputComponent {
    constructor(value, onChange, placeholder = "Lat, Lng") {
      super(value, onChange);
      this.placeholder = placeholder;
      this.element = this.createInput();
    }
    createInput() {
      const input = createElement("input", { type: "text", placeholder: this.placeholder });
      input.value = this.value ? `${this.value.lat}, ${this.value.lng}` : "";
      input.addEventListener("input", (e) => {
        const parts = e.target.value.split(",");
        const lat = parseFloat(parts[0]?.trim());
        const lng = parseFloat(parts[1]?.trim());
        this.onChange(!isNaN(lat) && !isNaN(lng) ? { lat, lng } : null);
      });
      return input;
    }
  }

  class ColorInput extends InputComponent {
    constructor(value, onChange) {
      super(value, onChange);
      this.element = this.createInput();
    }
    createInput() {
      const input = createElement("input", { type: "color" });
      input.value = this.value || "#000000";
      input.addEventListener("input", (e) => this.onChange(e.target.value));
      return input;
    }
  }

  class ColorPreview extends UIComponent {
    constructor(color) {
      super();
      this.element = createElement("span", { class: "color-preview" });
      this.setColor(color);
    }
    setColor(color) { this.element.style.backgroundColor = color; }
  }

  class UnitLabel extends UIComponent {
    constructor(unit) { super(); this.element = createElement("span", { class: "unit-label" }, ` ${unit || ""}`); }
  }

  class RemoveTagButton extends UIComponent {
    constructor(onRemove) {
      super();
      this.onRemove = onRemove;
      this.element = createElement("span", { class: "remove-tag" }, "×");
      this.element.addEventListener("click", (e) => { e.stopPropagation(); onRemove(); });
    }
  }

  /*****************************************************************
   * Abstract Tag Input Control & Subclasses
   *****************************************************************/
  class TagInputControl extends UIComponent {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    getElement() { throw new Error("Abstract method 'getElement' must be implemented"); }
  }

  class NumericTagInputControl extends TagInputControl {
    getElement() {
      const frag = document.createDocumentFragment();
      const mode = this.tag.data.mode;
      const update = () => this.tag.updateTagData();
      const createNumInput = (key, placeholder) => {
        const input = new NumberInput(this.tag.data[key], (v) => { this.tag.data[key] = v; update(); }, placeholder);
        return input.getElement();
      };
      if (mode === "is") {
        frag.appendChild(createNumInput("value", ""));
      } else if (mode === "is between") {
        frag.appendChild(createNumInput("min", "Min"));
        frag.appendChild(document.createTextNode(" and "));
        frag.appendChild(createNumInput("max", "Max"));
      } else if (mode === "is below" || mode === "is above") {
        const key = mode === "is below" ? "max" : "min";
        frag.appendChild(createNumInput(key, mode === "is below" ? "Max" : "Min"));
      }
      frag.appendChild(new UnitLabel(this.tag.data.unit).getElement());
      return frag;
    }
  }

  class ListTagInputControl extends TagInputControl {
    getElement() {
      return new ListInput(this.tag.data.options, this.tag.data.value, (v) => {
        this.tag.data.value = v;
        this.tag.updateTagData();
      }).getElement();
    }
  }

  class LocationTagInputControl extends TagInputControl {
    getElement() {
      return new LocationInput(this.tag.data.value, (v) => {
        this.tag.data.value = v;
        this.tag.updateTagData();
      }).getElement();
    }
  }

  class ColorTagInputControl extends TagInputControl {
    getElement() {
      const frag = document.createDocumentFragment();
      const colorInput = new ColorInput(this.tag.data.value, (v) => {
        this.tag.data.value = v;
        this.tag.updateTagData();
      });
      frag.appendChild(colorInput.getElement());
      frag.appendChild(new ColorPreview(this.tag.data.value).getElement());
      return frag;
    }
  }

  class TimeTagInputControl extends TagInputControl {
    getElement() {
      const frag = document.createDocumentFragment();
      const mode = this.tag.data.mode;
      const update = () => this.tag.updateTagData();
      const createTextInput = (key, placeholder) => {
        const input = new TextInput(this.tag.data[key], (v) => { this.tag.data[key] = v; update(); }, placeholder);
        return input.getElement();
      };
      if (mode === "is") {
        frag.appendChild(createTextInput("value", ""));
      } else if (mode === "is between") {
        frag.appendChild(createTextInput("min", "Start Time"));
        frag.appendChild(document.createTextNode(" and "));
        frag.appendChild(createTextInput("max", "End Time"));
      } else if (mode === "is before" || mode === "is after") {
        const key = mode === "is before" ? "max" : "min";
        frag.appendChild(createTextInput(key, mode === "is before" ? "Before" : "After"));
      }
      return frag;
    }
  }

  /*****************************************************************
   * Tag Class (Semantic Tag)
   *****************************************************************/
  class Tag extends UIComponent {
    constructor(tagData) {
      super();
      // Use a default mode if none provided.
      this.data = { ...tagData, mode: tagData.mode || Object.keys(tagData.modes)[0] };
      this.initializeValues();
      this.element = this.createElement();
    }
    initializeValues() {
      if (["number", "range"].includes(this.data.type))
        this.data.value = this.data.value ?? 0;
      else if (this.data.type === "list")
        this.data.value = this.data.value ?? (this.data.options?.[0] || "");
      else if (this.data.type === "color")
        this.data.value = this.data.value ?? "#000000";
    }
    createElement() {
      const tagEl = createElement("span", { class: `tag ${this.isConditional() ? "conditional" : ""}`, contenteditable: "false" });
      tagEl.appendChild(document.createTextNode(`${this.data.name} `));
      tagEl.appendChild(this.createModeSelect());
      this.rebuildInputs(tagEl);
      return tagEl;
    }
    createModeSelect() {
      const select = createElement("select");
      for (const mode in this.data.modes) {
        select.appendChild(new Option(this.data.modes[mode], mode));
      }
      select.value = this.data.mode;
      select.addEventListener("change", () => {
        this.data.mode = select.value;
        this.adjustValuesForMode();
        this.rebuildInputs(this.element);
        this.updateTagData();
      });
      return select;
    }
    isConditional() { return this.data.mode !== "is" && String(this.data.mode).startsWith("is"); }
    adjustValuesForMode() {
      if (this.data.mode === "is between") { this.data.min = this.data.min ?? 0; this.data.max = this.data.max ?? 0; }
      else if (this.data.mode === "is below") { this.data.max = this.data.max ?? 0; this.data.min = null; }
      else if (this.data.mode === "is above") { this.data.min = this.data.min ?? 0; this.data.max = null; }
      else { this.data.value = this.data.value ?? (this.data.type === "list" ? this.data.options[0] : 0); }
    }
    rebuildInputs(tagEl) {
      tagEl.querySelectorAll("input, select:not(:first-of-type), .color-preview, .unit-label").forEach(el => el.remove());
      let control;
      switch (this.data.type) {
        case "number":
        case "range": control = new NumericTagInputControl(this); break;
        case "list": control = new ListTagInputControl(this); break;
        case "location": control = new LocationTagInputControl(this); break;
        case "color": control = new ColorTagInputControl(this); break;
        case "time": control = new TimeTagInputControl(this); break;
      }
      if (control) tagEl.appendChild(control.getElement());
      tagEl.appendChild(new RemoveTagButton(() => tagEl.remove()).getElement());
    }
    updateTagData() { this.element.dataset.tagData = JSON.stringify(this.data); }
  }

  /*****************************************************************
   * Suggestion Dropdown
   *****************************************************************/
  class SuggestionDropdown extends UIComponent {
    constructor() {
      super();
      this.element = createElement("div", { id: "suggestion-dropdown" });
      this.hide();
      document.body.appendChild(this.element);
      this.selectedIndex = -1;
    }
    show(suggestions, x, y, onSelect) {
      this.element.innerHTML = "";
      suggestions.forEach((sugg, i) => {
        const suggEl = createElement("div", {}, sugg.displayText);
        suggEl.dataset.index = i;
        suggEl.addEventListener("click", () => { onSelect(sugg); this.hide(); });
        this.element.appendChild(suggEl);
      });
      this.element.style.left = `${x}px`;
      this.element.style.top = `${y}px`;
      this.element.style.display = "block";
      this.selectedIndex = -1;
      this.updateSelection();
    }
    hide() { this.element.style.display = "none"; }
    moveSelection(dir) {
      const count = this.element.children.length;
      if (!count) return;
      this.selectedIndex = (this.selectedIndex + dir + count) % count;
      this.updateSelection();
    }
    updateSelection() {
      Array.from(this.element.children).forEach((child, i) =>
              child.classList.toggle("selected", i === this.selectedIndex)
      );
    }
    getSelectedSuggestion() {
      return this.selectedIndex >= 0 && this.selectedIndex < this.element.children.length
              ? this.element.children[this.selectedIndex].textContent
              : null;
    }
  }

  /*****************************************************************
   * Ontology Browser
   *****************************************************************/
  class OntologyBrowser extends UIComponent {
    constructor(ontology, onTagSelect) {
      super();
      this.ontology = ontology;
      this.onTagSelect = onTagSelect;
      this.element = this.createBrowser();
    }
    createBrowser() {
      const browser = createElement("div", { id: "ontology-browser" });
      for (const category in this.ontology) {
        const catDiv = createElement("div", { class: "category" }, category);
        this.ontology[category].forEach(tagData => {
          const tagItem = createElement("div", { class: "tag-item" }, tagData.name);
          tagItem.addEventListener("click", () => this.onTagSelect(new Tag(tagData)));
          catDiv.appendChild(tagItem);
        });
        browser.appendChild(catDiv);
      }
      return browser;
    }
    show() {
      this.element.style.display = "block";
    }
    hide() { this.element.style.display = "none"; }
  }

  /*****************************************************************
   * Semantic Editor
   *****************************************************************/
  class SemanticEditor extends UIComponent {
    constructor(editorEl, ontology) {
      super();
      this.editor = editorEl;
      this.ontology = ontology;
      this.ontologyBrowser = new OntologyBrowser(this.ontology, this.insertTagFromOntology.bind(this));
      document.body.appendChild(this.ontologyBrowser.getElement());
      this.suggestionDropdown = new SuggestionDropdown();
      this.suggestionTimeout = null;
      this.setupEventListeners();
    }
    insertTagFromOntology(tag) {
      this.insertTagAtSelection(tag);
      this.ontologyBrowser.hide();
    }
    insertTagAtSelection(tag) {
      const sel = window.getSelection();
      if (sel.rangeCount) {
        const range = sel.getRangeAt(0);
        range.deleteContents();
        range.insertNode(tag.getElement());
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
      } else {
        this.editor.appendChild(tag.getElement());
      }
    }
    insertTagFromSuggestion(sugg) {
      const sel = window.getSelection();
      if (sel.rangeCount) {
        const range = sel.getRangeAt(0);
        if (range.startContainer.nodeType === Node.TEXT_NODE) {
          range.startContainer.textContent = range.startContainer.textContent.replace(/(\s*\S+)$/, "");
        }
        this.insertTagAtSelection(new Tag(sugg.tagData));
      }
    }
    serialize() {
      const clone = this.editor.cloneNode(true);
      clone.querySelectorAll(".tag").forEach(tagEl => {
        const data = JSON.parse(tagEl.dataset.tagData);
        tagEl.replaceWith(document.createTextNode(`[TAG:${JSON.stringify(data)}]`));
      });
      return clone.textContent;
    }
    deserialize(text) {
      this.editor.innerHTML = "";
      const tagRegex = /\[TAG:(.*?)\]/g;
      let lastIndex = 0, match;
      while ((match = tagRegex.exec(text)) !== null) {
        if (match.index > lastIndex) {
          this.editor.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
        }
        try {
          const data = JSON.parse(match[1]);
          this.editor.appendChild(new Tag(data).getElement());
        } catch (e) {
          console.error("Error parsing tag:", e);
          this.editor.appendChild(document.createTextNode(match[0]));
        }
        lastIndex = tagRegex.lastIndex;
      }
      if (lastIndex < text.length) {
        this.editor.appendChild(document.createTextNode(text.substring(lastIndex)));
      }
    }
    setupEventListeners() {
      document.getElementById("focus-editor").addEventListener("click", () => this.editor.focus());
      document.getElementById("show-ontology").addEventListener("click", () => {
        const visible = this.ontologyBrowser.getElement().style.display !== "none";
        visible ? this.ontologyBrowser.hide() : this.ontologyBrowser.show();
      });
      document.getElementById("serialize").addEventListener("click", () => {
        document.getElementById("serialization-output").value = this.serialize();
      });
      document.getElementById("serialization-output").addEventListener("input", () => this.deserialize(document.getElementById("serialization-output").value));
      this.editor.addEventListener("input", () => {
        clearTimeout(this.suggestionTimeout);
        this.suggestionTimeout = setTimeout(() => this.showSuggestions(), 250);
      });
      this.editor.addEventListener("keydown", (e) => {
        if (this.suggestionDropdown.element.style.display === "block") {
          switch (e.key) {
            case "ArrowDown":
              e.preventDefault();
              this.suggestionDropdown.moveSelection(1);
              break;
            case "ArrowUp":
              e.preventDefault();
              this.suggestionDropdown.moveSelection(-1);
              break;
            case "Enter":
              e.preventDefault();
              const selText = this.suggestionDropdown.getSelectedSuggestion();
              if (selText) {
                const suggestion = this.findSuggestion(selText);
                if (suggestion) this.insertTagFromSuggestion(suggestion);
              }
              this.suggestionDropdown.hide();
              break;
            case "Escape":
              e.preventDefault();
              this.suggestionDropdown.hide();
              break;
          }
        }
      });
      document.addEventListener("click", (e) => {
        if (!this.editor.contains(e.target) && !this.ontologyBrowser.getElement().contains(e.target)) {
          this.suggestionDropdown.hide();
        }
      });
    }
    isInTag() {
      const sel = window.getSelection();
      return sel.rangeCount && sel.getRangeAt(0).startContainer.parentElement.closest(".tag") !== null;
    }
    showSuggestions() {
      if (this.isInTag()) { this.suggestionDropdown.hide(); return; }
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const textBefore = range.startContainer.textContent.substring(0, range.startOffset);
      const words = textBefore.split(/\s+/);
      const lastWord = words[words.length - 1];
      if (!lastWord) { this.suggestionDropdown.hide(); return; }
      const suggestions = [];
      for (const cat in this.ontology) {
        for (const tagData of this.ontology[cat]) {
          if (tagData.name.toLowerCase().startsWith(lastWord.toLowerCase()))
            suggestions.push({ displayText: tagData.name, tagData });
        }
      }
      if (suggestions.length) {
        const rect = range.getBoundingClientRect();
        this.suggestionDropdown.show(suggestions, rect.left + window.scrollX, rect.bottom + window.scrollY,
                this.insertTagFromSuggestion.bind(this));
      } else {
        this.suggestionDropdown.hide();
      }
    }
    findSuggestion(text) {
      for (const cat in this.ontology) {
        for (const tagData of this.ontology[cat]) {
          if (tagData.name === text) return { displayText: tagData.name, tagData };
        }
      }
      return null;
    }
  }

  /*****************************************************************
   * Initialization
   *****************************************************************/
  const editor = document.getElementById("editor");
  const semanticEditor = new SemanticEditor(editor, ontology);
</script>
</body>
</html>
