<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Collaborative Reality Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="index.css" rel="stylesheet">
    <style>
        /* --- Global & Layout Styles --- */
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 0;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar-left {
            width: 200px;
            background: #f7f7f7;
            border-right: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box;
        }
        .main-content {
            flex: 1;
            padding: 10px;
            box-sizing: border-box;
        }
        .view {
            display: none;
        }
        .view.active {
            display: block;
        }

        /* --- Editor & Toolbar Styles --- */
        #editor-container {
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
        }
        .toolbar {
            border-bottom: 1px solid #ccc;
            margin-bottom: 5px;
            padding-bottom: 5px;
        }
        .toolbar button {
            margin-right: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        #editor {
            min-height: 200px;
            outline: none;
        }
        .metadata-panel {
            margin-top: 10px;
        }
        .metadata-panel input {
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
        }

        /* --- Inline Tag Styles --- */
        .inline-tag {
            background-color: #e0f7fa;
            border: 1px solid #00838f;
            border-radius: 4px;
            margin: 0 2px;
            padding: 2px 4px;
            display: inline-flex;
            align-items: center;
        }
        .inline-tag .tag-name {
            font-weight: bold;
            margin-right: 4px;
        }
        .inline-tag select.tag-condition {
            margin-right: 4px;
        }
        .inline-tag input.tag-value {
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px;
            width: 80px;
            margin-right: 4px;
        }
        .inline-tag button.tag-remove {
            background: none;
            border: none;
            color: #d00;
            font-weight: bold;
            cursor: pointer;
        }

        /* --- Popup Menu Styles --- */
        .popup-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #aaa;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 3px;
            z-index: 1000;
            display: none;
        }
        .popup-menu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .popup-menu li {
            padding: 5px;
            cursor: pointer;
        }
        .popup-menu li:hover {
            background-color: #f0f0f0;
        }

        /* --- Notification Area --- */
        #notification-area {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #ffd;
            border: 1px solid #ccc;
            padding: 10px;
            display: none;
            z-index: 1000;
        }
    </style>

    <!-- --- External Libraries --- -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval@6.2.0/dist/umd.js"></script>

    <!-- --- Main JavaScript (ES Module) --- -->
    <script type="module">
        import { relayInit, getEventHash, signEvent, getPublicKey } from "https://esm.sh/nostr-tools@1.8.0";
        import * as dateFns from "https://cdn.jsdelivr.net/npm/date-fns@2.29.3/esm/index.js";
        import * as nanoid from "https://cdn.jsdelivr.net/npm/nanoid@5.0.9/nanoid.js";

        const { set, get, del, keys: idbKeys } = idbKeyval;
        const KEY_STORAGE = "nostr_keys";

        // --- Key Generation & Storage ---
        const generateNostrPrivateKey = () => {
            const array = new Uint8Array(32);
            window.crypto.getRandomValues(array);
            return Array.from(array)
                .map((b) => b.toString(16).padStart(2, "0"))
                .join("");
        };

        const getKeys = async () => {
            try {
                let keysData = await get(KEY_STORAGE);
                if (!keysData) {
                    const priv = generateNostrPrivateKey();
                    const pub = getPublicKey(priv);
                    keysData = { priv, pub };
                    await set(KEY_STORAGE, keysData);
                }
                return keysData;
            } catch (error) {
                console.error("Error accessing IndexedDB for keys:", error);
                alert("Failed to access keys. IndexedDB might be unavailable.");
                return null;
            }
        };

        // --- Ontology & Available Tags ---
        const ontology = {
            General: {
                Location: {
                    dataType: "location",
                    conditions: {
                        exact: { label: "is exactly" },
                        approx: { label: "is near" },
                    },
                    defaultCondition: "exact",
                    allowedNatures: ["definite", "indefinite"],
                },
                Time: {
                    dataType: "time",
                    conditions: {
                        exact: { label: "is exactly" },
                        before: { label: "is before" },
                        after: { label: "is after" },
                        between: { label: "is between" },
                    },
                    defaultCondition: "exact",
                    allowedNatures: ["definite", "indefinite"],
                },
            },
            Emotion: {
                Mood: {
                    dataType: "string",
                    conditions: { exact: { label: "is" } },
                    defaultCondition: "exact",
                    allowedNatures: ["definite"],
                },
            },
        };

        // For inline tag insertion, we define available tags.
        const availableTags = [
            { name: "Weight", defaultCondition: "is" },
            { name: "Location", defaultCondition: "is" },
            { name: "Time", defaultCondition: "is" },
            { name: "Mood", defaultCondition: "is" }
        ];

        // --- Inline Tag Helpers ---

        let savedRange = null;
        function saveSelection() {
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                savedRange = sel.getRangeAt(0);
            }
        }
        function restoreSelection() {
            if (savedRange) {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(savedRange);
            }
        }
        function getCaretCoordinates() {
            let x = 0, y = 0;
            const sel = window.getSelection();
            if (sel.rangeCount) {
                const range = sel.getRangeAt(0).cloneRange();
                range.collapse(true);
                const rects = range.getClientRects();
                if (rects.length > 0) {
                    const rect = rects[0];
                    x = rect.left;
                    y = rect.top;
                }
            }
            return { x, y };
        }

        // NEW: ensure the caret is inside the editor before any insertion.
        function ensureFocusInEditor() {
            const editor = document.getElementById('editor');
            if (!editor.contains(document.activeElement)) {
                editor.focus();
                // Move caret to the end of the contentEditable.
                const range = document.createRange();
                range.selectNodeContents(editor);
                range.collapse(false);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
                saveSelection();
            }
        }

        function insertInlineTag(tag) {
            ensureFocusInEditor();
            restoreSelection();
            const widget = new InlineTagWidget(tag.name, tag.defaultCondition, "");
            // Insert the widget at the caret
            const sel = window.getSelection();
            if (sel.rangeCount) {
                const range = sel.getRangeAt(0);
                range.deleteContents();
                range.insertNode(widget.$el.get(0));
                // Move caret after widget
                range.setStartAfter(widget.$el.get(0));
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }
        function showTagPopup() {
            ensureFocusInEditor();
            saveSelection();
            const coords = getCaretCoordinates();
            const $popup = $('#tag-popup');
            const $ul = $popup.find('ul');
            $ul.empty();
            availableTags.forEach(tag => {
                const $li = $('<li>' + tag.name + '</li>');
                $li.on('click', function() {
                    insertInlineTag(tag);
                    $popup.hide();
                    $('#editor').focus();
                });
                $ul.append($li);
            });
            $popup.css({
                left: coords.x + 'px',
                top: (coords.y + 20) + 'px'
            }).show();
        }

        // --- Inline Tag Widget Class with Dropdown ---
        class InlineTagWidget {
            constructor(tagName, condition, value) {
                this.tagName = tagName;
                this.condition = condition || "is";
                this.value = value || (this.condition === "between" ? { lower: "", upper: "" } : "");
                this.$el = $('<span class="inline-tag" contenteditable="false"></span>');
                this.render();
            }
            render() {
                this.$el.empty();
                // Display tag name
                this.$el.append($(`<span class="tag-name">${this.tagName}</span>`));
                // Create a dropdown select for condition/mode
                this.$select = $('<select class="tag-condition"></select>');
                const conditionOptions = [
                    { value: "is", label: "is", nature: "definite" },
                    { value: "between", label: "between", nature: "indefinite" },
                    { value: "gt", label: "(gt)", nature: "indefinite" },
                    { value: "lt", label: "lt", nature: "indefinite" }
                ];
                conditionOptions.forEach(option => {
                    const $option = $(`<option value="${option.value}" data-nature="${option.nature}">${option.label}</option>`);
                    if (option.value === this.condition) {
                        $option.prop("selected", true);
                    }
                    this.$select.append($option);
                });
                this.$el.append(this.$select);
                // Depending on condition, create one or two input fields
                if (this.condition === "between") {
                    this.$lower = $(`<input type="text" class="tag-value lower" placeholder="min" value="${(this.value && this.value.lower) || ''}">`);
                    this.$upper = $(`<input type="text" class="tag-value upper" placeholder="max" value="${(this.value && this.value.upper) || ''}">`);
                    this.$el.append(this.$lower, " and ", this.$upper);
                } else {
                    this.$valueInput = $(`<input type="text" class="tag-value" placeholder="Enter value" value="${this.value || ''}">`);
                    this.$el.append(this.$valueInput);
                }
                // Remove button
                this.$el.append($(`<button class="tag-remove" title="Remove tag">x</button>`));
                this.attachEvents();
            }
            attachEvents() {
                // When the dropdown changes, update the condition and re‑render.
                this.$select.on("change", () => {
                    this.setCondition(this.$select.val());
                });
                // Update the widget when the input loses focus.
                this.$el.find("input").on("blur", () => this.updateFromInputs());
                // Remove the tag when the remove button is clicked.
                this.$el.find(".tag-remove").on("click", (e) => {
                    e.preventDefault();
                    this.removeTag();
                });
            }
            updateFromInputs() {
                if (this.condition === "between") {
                    this.value = { lower: this.$lower.val(), upper: this.$upper.val() };
                } else {
                    this.value = this.$valueInput.val();
                }
                this.debouncedUpdateNobject();
            }
            removeTag() {
                setTimeout(() => this.$el.remove(), 0);
                this.updateNobject();
            }
            setCondition(newCondition) {
                this.condition = newCondition;
                // Reset the value when the condition changes.
                this.value = (this.condition === "between") ? { lower: "", upper: "" } : "";
                this.render();
                this.updateNobject();
            }
            updateNobject = () => {
                if (window.app && window.app.selected) {
                    window.app.selected.content = window.app.$editor.html();
                    window.app.store.save(window.app.selected)
                        .then(() => window.nostrClient.publish(window.app.selected))
                        .catch((error) => {
                            console.error("Error in updateNobject:", error);
                        });
                }
            };
            debouncedUpdateNobject = _.debounce(this.updateNobject, 500);
        }

        // ------------------ App Classes ------------------
        class Sidebar {
            constructor() {
                this.$el = $('<div class="sidebar-left"></div>');
                this.buildMenu();
                this.buildSidebarLinks();
                this.buildNostrStatus();
                this.buildNostrFeed();
            }
            buildMenu() {
                const menuItems = [
                    { label: "Me", view: "me-view" },
                    { label: "Friends", view: "friends-view" },
                    { label: "Network", view: "network-view" },
                    { label: "Database", view: "database-view" },
                    { label: "Settings", view: "settings-view" },
                ];
                this.$el.append(
                    $("<h3>Menu</h3>"),
                    $("<ul></ul>").append(
                        menuItems.map(item =>
                            $(`<li><a href="#" data-view="${item.view}">${item.label}</a></li>`)
                        )
                    ),
                    $("<hr>")
                );
            }
            buildSidebarLinks() {
                const links = [
                    { label: "Recent Objects", list: "recent" },
                    { label: "Matches", list: "matches" },
                ];
                this.$el.append(
                    $("<h3>Sidebar</h3>"),
                    $("<ul></ul>").append(
                        links.map(link =>
                            $(`<li><a href="#" data-list="${link.list}">${link.label}</a></li>`)
                        )
                    ),
                    $("<hr>")
                );
            }
            buildNostrStatus() {
                this.$el.append(
                    $("<h3>Nostr Status</h3>"),
                    $('<div id="nostr-connection-status">Connecting...</div>'),
                    $("<hr>")
                );
            }
            buildNostrFeed() {
                this.$el.append(
                    $("<h3>Nostr Feed</h3>"),
                    $('<div id="nostr-feed" style="max-height: 150px; overflow-y: auto;"></div>')
                );
            }
        }

        class SimpleView {
            constructor(title, content) {
                this.$el = $(`<div class="view" style="display: none;"><h2>${title}</h2><p>${content}</p></div>`);
            }
        }

        class DatabaseView {
            constructor() {
                this.$el = $('<div id="database-view" class="view active"></div>');
                this.$filterBar = $(`
          <div class="filter-bar">
            <input type="text" id="search-input" placeholder="Search TODOs..." />
            <button id="search-btn">Search</button>
          </div>
        `);
                this.$objectList = $('<div id="object-list"></div>');
                this.$newObjectBtn = $('<button id="new-object-btn">New TODO</button>');
                this.$editorContainer = $(`
          <div id="editor-container" style="display: none;">
            <div class="toolbar">
              <button id="bold-btn"><b>B</b></button>
              <button id="italic-btn"><i>I</i></button>
              <button id="insert-tag-btn">Insert Tag</button>
            </div>
            <div id="editor" contenteditable="true"></div>
            <div class="metadata-panel">
              <label for="object-name">Name:</label>
              <input type="text" id="object-name" />
            </div>
            <button id="save-object-btn">Save</button>
            <button id="cancel-edit-btn">Cancel</button>
          </div>
        `);
                this.$el.append(this.$filterBar, this.$objectList, this.$newObjectBtn, this.$editorContainer);
            }
        }

        class MainContent {
            constructor() {
                this.$el = $('<div class="main-content"></div>').append($('<div class="content"></div>'));
                this.views = {
                    "database-view": new DatabaseView(),
                    "me-view": new SimpleView("User Profile", "Your personal profile and settings."),
                    "friends-view": new SimpleView("Friends", "Friend activity and connection updates."),
                    "network-view": new SimpleView("Network Activity", "Relay messages and network events."),
                    "settings-view": new SimpleView("Settings", "Application configuration.")
                };
                _.forEach(this.views, (view) => {
                    this.$el.find(".content").append(view.$el);
                });
            }
            showView(viewName) {
                this.$el.find(".view").removeClass("active").hide();
                if (this.views[viewName]) {
                    this.views[viewName].$el.addClass("active").show();
                }
            }
        }

        // Matcher: checks incoming events against stored objects’ inline tags
        class Matcher {
            constructor(app) {
                this.app = app;
            }
            async matchEvent(ev) {
                const eventText = ev.content.toLowerCase();
                const matches = [];
                const objs = await this.app.store.getAll();
                for (const obj of objs) {
                    const $temp = $("<div></div>").html(obj.content);
                    let matchedTagCount = 0;
                    $temp.find(".inline-tag").each((index, element) => {
                        const $tag = $(element);
                        const tagName = $tag.find(".tag-name").text();
                        const tagDef = ontology.General[tagName] || ontology.Emotion[tagName];
                        if (!tagDef) return;
                        const condition = $tag.find("select.tag-condition").val();
                        let tagMatched = false;
                        if (condition === "between") {
                            const lower = parseFloat($tag.find("input.lower").val());
                            const upper = parseFloat($tag.find("input.upper").val());
                            const numbersInEvent = eventText.match(/\d+/g)?.map(Number) || [];
                            tagMatched = numbersInEvent.some(num =>
                                !isNaN(lower) && !isNaN(upper) && num >= lower && num <= upper
                            );
                        } else {
                            const tagVal = $tag.find("input.tag-value").val()?.toLowerCase();
                            if (tagVal) {
                                tagMatched = condition === "is" ? eventText === tagVal : eventText.includes(tagVal);
                            }
                        }
                        if (tagMatched) matchedTagCount++;
                    });
                    if (matchedTagCount > 0) matches.push(obj);
                }
                if (matches.length > 0) {
                    this.app.notifyMatch(matches, ev);
                }
            }
        }

        // NObjectStore using idb-keyval for persistence
        class NObjectStore {
            async getAll() {
                try {
                    const allKeys = await idbKeys();
                    const allObjs = await Promise.all(allKeys.map(key => get(key)));
                    return _.orderBy(
                        allObjs.filter(obj => obj != null),
                        ["updatedAt"],
                        ["desc"]
                    );
                } catch (error) {
                    console.error("Error getting all objects:", error);
                    alert("Failed to retrieve data. IndexedDB might be unavailable.");
                    return [];
                }
            }
            async save(o) {
                if (!o.id) {
                    console.error("Attempted to save an object without an id:", o);
                    throw new Error("Missing id property on object");
                }
                try {
                    await set(o.id, o);
                    return o;
                } catch (error) {
                    console.error("Error saving object:", error);
                    alert("Failed to save data. IndexedDB might be unavailable.");
                    throw error;
                }
            }
            async delete(id) {
                try {
                    await del(id);
                } catch (error) {
                    console.error("Error deleting object:", error);
                    alert("Failed to delete data. IndexedDB might be unavailable.");
                }
            }
        }

        // Nostr Client to handle relay connections and event publishing
        class NostrClient {
            constructor(matcher) {
                this.matcher = matcher;
                this.relayUrl = "wss://relay.damus.io";
                this.relay = relayInit(this.relayUrl);
                this.setupRelayEvents();
                this.relay.connect();
            }
            setupRelayEvents() {
                this.relay.on("connect", () => {
                    console.log("Connected to relay");
                    $("#nostr-connection-status").text("Connected");
                    this.subscribe();
                    this.subscribeFeed();
                });
                this.relay.on("error", (err) => {
                    console.error("Relay error", err);
                    $("#nostr-connection-status").text(`Error: ${err}`);
                });
                this.relay.on("disconnect", () => {
                    console.log("Disconnected");
                    $("#nostr-connection-status").text("Disconnected");
                });
            }
            subscribe() {
                this.relay.sub([{ kinds: [30000] }]).on("event", (ev) => {
                    try {
                        if (!ev.content || ev.content.trim()[0] !== "{") return;
                        const data = JSON.parse(ev.content);
                        if (!data.id) return;
                        const sanitizedContent = DOMPurify.sanitize(data.content);
                        window.app.store.getAll().then(allObjs => {
                            const existingObj = allObjs.find(o => o.id === data.id);
                            const nobj = existingObj
                                ? { ...existingObj, name: data.name, content: sanitizedContent, tags: ev.tags.filter(t => t[0] === "t").map(t => t[1]), updatedAt: ev.created_at * 1000 }
                                : { id: data.id, name: data.name, content: sanitizedContent, tags: ev.tags.filter(t => t[0] === "t").map(t => t[1]), createdAt: ev.created_at * 1000, updatedAt: ev.created_at * 1000 };
                            window.app.store.save(nobj).then(() => window.app.renderList());
                        });
                    } catch (e) {
                        console.error("Parsing error", e);
                    }
                });
            }
            subscribeFeed() {
                this.relay.sub([{ kinds: [1] }]).on("event", (ev) => {
                    const timeStr = dateFns.format(new Date(ev.created_at * 1000), "p");
                    $("#nostr-feed")
                        .prepend(
                            `<div>[${timeStr}] ${ev.pubkey}: ${DOMPurify.sanitize(ev.content)}</div>`
                        )
                        .children(":gt(19)")
                        .remove();
                    this.matcher.matchEvent(ev);
                });
            }
            publish(nobj) {
                const sanitizedContent = DOMPurify.sanitize(nobj.content);
                const content = JSON.stringify({
                    id: nobj.id,
                    name: nobj.name,
                    content: sanitizedContent,
                });
                const ev = {
                    pubkey: window.keys.pub,
                    created_at: Math.floor(nobj.updatedAt / 1000),
                    kind: 30000,
                    tags: nobj.tags.map(tag => ["t", tag]),
                    content,
                };
                ev.id = getEventHash(ev);
                ev.sig = signEvent(ev, window.keys.priv);
                this.relay.publish(ev);
            }
        }

        // Main App Class: ties everything together
        class App {
            constructor() {
                this.store = new NObjectStore();
                this.selected = null;
                this.matcher = new Matcher(this);
                this.debouncedRenderList = _.debounce((filter) => this.renderList(filter), 300);
                this.initUI();
            }
            async initUI() {
                this.$container = $('<div class="container"></div>');
                this.sidebar = new Sidebar();
                this.mainContent = new MainContent();
                this.$container.append(this.sidebar.$el, this.mainContent.$el);
                $("body").append(
                    this.$container,
                    $('<div id="notification-area"></div>'),
                    $('<div class="loading-overlay"><div class="spinner"></div></div>'),
                    $('<div id="tag-popup" class="popup-menu"><ul></ul></div>')
                );
                // Now that the elements are in the DOM, grab the editor and name input.
                this.$editor = $("#editor");
                this.$objectNameInput = $("#object-name");
                this.renderList();
                this.setupEventHandlers();
            }
            setupEventHandlers() {
                this.sidebar.$el.on("click", "a[data-view]", (e) => {
                    e.preventDefault();
                    this.setView($(e.currentTarget).data("view"));
                });
                this.sidebar.$el.on("click", "a[data-list]", (e) => {
                    e.preventDefault();
                    if ($(e.currentTarget).data("list") === "recent") {
                        this.setView("database-view");
                        this.renderList();
                    }
                });
                $("#search-btn").on("click", () => {
                    this.debouncedRenderList($("#search-input").val());
                });
                $("#new-object-btn").on("click", () => this.createNewObject());
                $("#save-object-btn").on("click", () => this.saveObject());
                $("#cancel-edit-btn").on("click", () => this.hideEditor());
                $("#bold-btn").on("click", () => document.execCommand("bold"));
                $("#italic-btn").on("click", () => document.execCommand("italic"));
                $("#insert-tag-btn").on("click", (e) => {
                    e.preventDefault();
                    showTagPopup();
                });
                $("#object-list").on("click", ".object-item", async (e) => {
                    const id = $(e.currentTarget).data("id");
                    try {
                        const objs = await this.store.getAll();
                        const objToEdit = _.find(objs, { id });
                        if (objToEdit) {
                            this.editObject(objToEdit);
                        }
                    } catch (error) {
                        console.error("Error editing object: ", error);
                    }
                });
                // Save caret selection when the editor is used.
                this.$editor.on("mouseup keyup", function() {
                    saveSelection();
                });
                // Fix newline behavior:
                // On Enter, ensure the focus is in the editor and then insert a <br> or <br><br> if at the end.
                this.$editor.on("keydown", function(e) {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        ensureFocusInEditor();
                        const editor = e.currentTarget;
                        const sel = window.getSelection();
                        let atEnd = false;
                        if (sel.rangeCount > 0) {
                            const range = sel.getRangeAt(0);
                            // If the range is in a text node, check if caret is at its end;
                            // otherwise check if the range offset equals the number of child nodes.
                            if (range.endContainer.nodeType === Node.TEXT_NODE) {
                                atEnd = (range.endOffset === range.endContainer.length) &&
                                    (range.endContainer.parentNode === editor || range.endContainer.parentNode === editor.lastChild);
                            } else {
                                atEnd = range.endOffset === editor.childNodes.length;
                            }
                        }
                        if (atEnd) {
                            document.execCommand('insertHTML', false, '<br><br>');
                        } else {
                            document.execCommand('insertHTML', false, '<br>');
                        }
                        saveSelection();
                    }
                });
                // Hide tag popup when clicking outside of it or the Insert Tag button.
                $(document).on("click", (e) => {
                    if (!$(e.target).closest("#tag-popup, #insert-tag-btn").length) {
                        $("#tag-popup").hide();
                    }
                });
            }
            setView(v) {
                this.mainContent.showView(v);
                if (v !== "database-view") this.hideEditor();
            }
            async renderList(filter = "") {
                const $list = $("#object-list");
                try {
                    const objs = await this.store.getAll();
                    let filteredObjs = objs;
                    if (filter.trim()) {
                        const regex = new RegExp(_.escapeRegExp(filter), "i");
                        filteredObjs = _.filter(objs, (o) => regex.test(o.name) || regex.test(o.content));
                    }
                    $list.empty().append(
                        filteredObjs.length
                            ? _.map(filteredObjs, (o) => this.renderObjectItem(o))
                            : '<p>No TODO items found. Click "New TODO" to create one.</p>'
                    );
                } catch (error) {
                    console.error("Error rendering list: ", error);
                }
            }
            renderObjectItem(o) {
                const safeContent = DOMPurify.sanitize(o.content);
                const updatedStr = o.updatedAt ? dateFns.format(o.updatedAt, "Pp") : "?";
                return $(`
          <div class="object-item" data-id="${o.id}">
            <strong>${o.name}</strong>
            <div>${safeContent}</div>
            <small>Updated: ${updatedStr}</small>
          </div>
        `);
            }
            createNewObject() {
                this.showEditor({
                    id: nanoid.nanoid(),
                    name: "",
                    content: "",
                    tags: [],
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                });
            }
            editObject(o) {
                this.selected = o;
                this.showEditor(o);
            }
            showEditor(o) {
                this.$objectNameInput.val(o.name);
                this.$editor.html(DOMPurify.sanitize(o.content));
                $("#editor-container").show();
            }
            hideEditor() {
                $("#editor-container").hide();
                this.selected = null;
            }
            async saveObject() {
                const name = $("#object-name").val();
                if (!name || !name.trim()) {
                    alert("Name cannot be empty");
                    return;
                }
                const content = this.$editor.html();
                const now = Date.now();
                const sanitizedContent = DOMPurify.sanitize(content);
                const o = this.selected
                    ? { ...this.selected, name, content: sanitizedContent, updatedAt: now }
                    : {
                        id: nanoid.nanoid(),
                        name,
                        content: sanitizedContent,
                        tags: [],
                        createdAt: now,
                        updatedAt: now,
                    };
                try {
                    await this.store.save(o);
                    this.hideEditor();
                    this.renderList();
                    window.nostrClient.publish(o);
                } catch (error) {
                    console.error("Error in App.saveObject:", error);
                }
            }
            notifyMatch(matchedObjects, ev) {
                const msg = `Match found in ${matchedObjects.length} object(s) for event from ${ev.pubkey}:<br>${_.map(matchedObjects, (obj) => `<em>${obj.name}</em> (updated ${dateFns.format(obj.updatedAt, "Pp")})`).join("<br>")}`;
                $("#notification-area").html(msg).fadeIn(300).delay(3000).fadeOut(300);
            }
            showLoading() {
                $(".loading-overlay").show();
            }
            hideLoading() {
                $(".loading-overlay").hide();
            }
        }

        // --- Initialize the App & Nostr Client ---
        document.addEventListener("DOMContentLoaded", async () => {
            const app = new App();
            const loadedKeys = await getKeys();
            if (loadedKeys) {
                window.app = app;
                window.keys = loadedKeys;
                window.nostrClient = new NostrClient(app.matcher);
            }
        });
    </script>
</head>
<body>
<div id="app"></div>
</body>
</html>
