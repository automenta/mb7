<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Collaborative Reality Editor</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        .container { display: flex; height: 100vh; }
        .sidebar-left { width: 220px; background: #f0f0f0; padding: 10px; border-right: 1px solid #ccc; overflow-y: auto; }
        .sidebar-left h3 { margin-top: 0; }
        .sidebar-left ul { list-style: none; padding: 0; }
        .sidebar-left li { margin: 5px 0; }
        .sidebar-left a { text-decoration: none; color: #333; cursor: pointer; }
        .main-content { flex: 1; display: flex; flex-direction: column; }
        .content { flex: 1; padding: 10px; overflow-y: auto; }
        .view { display: none; }
        .view.active { display: block; }
        .filter-bar { margin-bottom: 10px; }
        .filter-bar input { padding: 5px; width: 200px; margin-right: 5px; }
        #object-list .object-item { border: 1px solid #ccc; margin-bottom: 5px; padding: 5px; cursor: pointer; }
        #object-list .object-item:hover { background: #fafafa; }
        .toolbar { background: #eee; padding: 5px; border: 1px solid #ccc; position: relative; }
        .toolbar button { margin-right: 5px; }
        #editor { border: 1px solid #ccc; min-height: 200px; padding: 10px; margin-bottom: 5px; }
        .metadata-panel { margin-bottom: 5px; }
        /* Inline Tag Styles (Adjusted for Context Menu) */
        .inline-tag {
            display: inline-block;
            background: #eef;
            border: 1px solid #99c;
            border-radius: 3px;
            padding: 2px 4px;
            margin: 0 2px;
            vertical-align: middle;
            cursor: pointer;
            position: relative; /* For positioning the context menu */
        }
        .inline-tag input {
            width: 50px;
            margin: 0 2px;
            border: none;
            background: #eef;
            text-align: center;
        }
        .inline-tag .tag-controls {
            display: inline-block;
            margin-left: 4px;
            font-size: 0.8em;
            color: #666;
            visibility: hidden;
            position: absolute;
            top: 100%;
            left: 0;
            background: #fff;
            border: 1px solid #ccc;
            z-index: 10;
            padding: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            white-space: nowrap;
        }
        .inline-tag:hover .tag-controls { visibility: visible; }
        .inline-tag .tag-controls button {
            background: none;
            border: 1px solid transparent;
            cursor: pointer;
            color: #c00;
            padding: 2px 5px;
            display: block;
            text-align: left;
        }
        .inline-tag .tag-controls button:hover {
            border-color: #ccc;
        }
        /* Tag Insertion Menu (Adjusted) */
        #tag-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            display: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1100;
            max-height: 300px;
            overflow-y: auto;
            min-width: 150px;
        }
        #tag-menu ul { list-style: none; padding: 0; margin: 0; }
        #tag-menu li { padding: 3px 0; cursor: pointer; white-space: nowrap; }
        #tag-menu li:hover, #tag-menu li.selected { background: #f0f0f0; }
        #tag-menu li.selected { background-color: #add8e6; }
        #tag-menu input[type="text"] { width: calc(100% - 12px); padding: 5px; margin-bottom: 5px; }
        /* Notification */
        #notification-area { position: fixed; bottom: 20px; right: 20px; width: 300px; background: #ffffcc; border: 1px solid #cccc99; padding: 10px; display: none; z-index: 1200; }
        .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 1300; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #fff; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb-keyval@6.2.0/dist/umd.js"></script>

    <script type="module">
        import { relayInit, getEventHash, signEvent, getPublicKey } from "https://esm.sh/nostr-tools@1.8.0";
        import * as dateFns from 'https://cdn.jsdelivr.net/npm/date-fns@2.29.3/esm/index.js';
        import * as nanoid from 'https://cdn.jsdelivr.net/npm/nanoid@5.0.9/nanoid.js';

        const { set, get, del, keys: idbKeys, clear } = idbKeyval;
        const KEY_STORAGE = "nostr_keys";
        const OBJECT_STORE_NAME = "nobjects";

        function generateNostrPrivateKey() {
            const array = new Uint8Array(32);
            window.crypto.getRandomValues(array);
            return Array.from(array)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        const getKeys = async () => {
            try {
                return await get(KEY_STORAGE) || await (async () => {
                    // Use the proper key generation function
                    const priv = generateNostrPrivateKey();
                    const pub = getPublicKey(priv);
                    const k = { priv, pub };
                    await set(KEY_STORAGE, k);
                    return k;
                })();
            } catch (error) {
                console.error("Error accessing IndexedDB for keys:", error);
                alert("Failed to access keys. IndexedDB might be unavailable.");
                return null;
            }
        };


        // Ontology definition
        const ontology = {
            "General": {
                "Location": { dataType: "location", conditions: { "exact": { label: "is exactly" }, "approx": { label: "is near" } }, defaultCondition: "exact", allowedNatures: ["definite", "indefinite"] },
                "Time": { dataType: "time", conditions: { "exact": { label: "is exactly" }, "before": { label: "is before" }, "after": { label: "is after" }, "between": { label: "is between" } }, defaultCondition: "exact", allowedNatures: ["definite", "indefinite"] }
            },
            "Emotion": { "Mood": { dataType: "string", conditions: { "exact": { label: "is" } }, defaultCondition: "exact", allowedNatures: ["definite"] } }
        };

        // Helper to find tag definitions
        const findTagDefinition = (tagName) => _.find(ontology, (category) => category[tagName])?.[tagName];

        // Insert node at current cursor position
        const insertNodeAtCursor = ($node) => {
            window.app.$editor.focus();
            const sel = window.getSelection();
            let range = sel?.rangeCount > 0 ? sel.getRangeAt(0) : window.savedRange;
            if (range) {
                range.deleteContents();
                range.insertNode($node.get(0));
                range.setStartAfter($node.get(0));
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
                window.savedRange = range;
            }
        };

        // Inline Tag Widget Class
        class InlineTagWidget {
            constructor(tagName, condition, value, nature) {
                this.tagName = tagName;
                const tagDef = findTagDefinition(tagName);
                this.condition = condition || tagDef?.defaultCondition || "exact";
                this.value = value || (this.condition === "between" ? { lower: "", upper: "" } : "");
                this.nature = nature || _.first(tagDef?.allowedNatures) || "indefinite";
                this.$el = $('<span class="inline-tag" contenteditable="false"></span>');
                this.$lower = null;
                this.$upper = null;
                this.$valueInput = null;
                this.render();
                this.attachEvents();
                this.contextMenuVisible = false;
            }

            render() {
                this.$el.empty().append($(`<span class="tag-name">${this.tagName}</span>`));
                const tagDef = findTagDefinition(this.tagName);
                const condLabel = tagDef?.conditions[this.condition]?.label || this.condition;
                this.$el.append($(`<span class="tag-condition"> ${condLabel} </span>`));
                if (this.condition === "between") {
                    this.$lower = $(`<input type="text" class="tag-value lower" placeholder="min" value="${this.value.lower}" />`);
                    this.$upper = $(`<input type="text" class="tag-value upper" placeholder="max" value="${this.value.upper}" />`);
                    this.$el.append(this.$lower, " and ", this.$upper);
                } else {
                    this.$valueInput = $(`<input type="text" class="tag-value" placeholder="value" value="${this.value}" />`);
                    this.$el.append(this.$valueInput);
                }
                this.$el.append($(`<span class="tag-nature"> (${this.nature})</span>`));
                this.populateContextMenu();
            }

            populateContextMenu() {
                const $controls = $(`<span class="tag-controls"></span>`);
                this.$el.append($controls);
                const tagDef = findTagDefinition(this.tagName);
                _.forEach(tagDef?.conditions, (condData, condKey) => {
                    $controls.append($(`<button data-action="setCondition" data-condition="${condKey}">${condData.label}</button>`));
                });
                _.forEach(tagDef?.allowedNatures, (nature) => {
                    $controls.append($(`<button data-action="setNature" data-nature="${nature}">${nature}</button>`));
                });
                $controls.append($(`<button data-action="remove">Remove Tag</button>`));
            }

            attachEvents() {
                this.$el.on('click', '[data-action]', (e) => {
                    e.stopPropagation();
                    const action = $(e.currentTarget).data('action');
                    switch (action) {
                        case 'remove': this.removeTag(); break;
                        case 'setCondition': this.setCondition($(e.currentTarget).data('condition')); break;
                        case 'setNature': this.setNature($(e.currentTarget).data('nature')); break;
                    }
                });
                this.$el.find("input").on("blur", () => this.updateFromInputs());
                $(document).on("click", (e) => {
                    if (!this.$el.is(e.target) && this.$el.has(e.target).length === 0 && this.contextMenuVisible) {
                        this.$el.find(".tag-controls").css("visibility", "hidden");
                        this.contextMenuVisible = false;
                    }
                });
            }

            updateFromInputs() {
                this.value = this.condition === "between"
                    ? { lower: this.$lower.val(), upper: this.$upper.val() }
                    : this.$valueInput.val();
                this.debouncedUpdateNobject();
            }

            removeTag() { setTimeout(() => this.$el.remove(), 0); this.updateNobject(); }
            setCondition(newCondition) {
                this.condition = newCondition;
                this.value = (newCondition === "between") ? { lower: "", upper: "" } : "";
                this.render();
                this.updateNobject();
            }
            setNature(newNature) {
                this.nature = newNature;
                this.render();
                this.updateNobject();
            }
            updateNobject = () => {
                if (window.app.selected) {
                    window.app.selected.content = window.app.$editor.html();
                    window.app.store.save(window.app.selected).then(() => {
                        nostrClient.publish(window.app.selected);
                    }).catch(error => {
                        console.error("Error in updateNobject:", error);
                    });
                }
            };
            debouncedUpdateNobject = _.debounce(this.updateNobject, 500);
        }

        // Sidebar Class
        class Sidebar {
            constructor() {
                this.$el = $('<div class="sidebar-left"></div>');
                this.buildMenu();
                this.buildSidebarLinks();
                this.buildNostrStatus();
                this.buildNostrFeed();
            }
            buildMenu() {
                const menuItems = [
                    { label: 'Me', view: 'me-view' },
                    { label: 'Friends', view: 'friends-view' },
                    { label: 'Network', view: 'network-view' },
                    { label: 'Database', view: 'database-view' },
                    { label: 'Settings', view: 'settings-view' }
                ];
                this.$el.append(
                    $('<h3>Menu</h3>'),
                    $('<ul></ul>').append(menuItems.map(item => $(`<li><a href="#" data-view="${item.view}">${item.label}</a></li>`))),
                    $('<hr>')
                );
            }
            buildSidebarLinks() {
                const links = [ { label: 'Recent Objects', list: 'recent' }, { label: 'Matches', list: 'matches' } ];
                this.$el.append(
                    $('<h3>Sidebar</h3>'),
                    $('<ul></ul>').append(links.map(link => $(`<li><a href="#" data-list="${link.list}">${link.label}</a></li>`))),
                    $('<hr>')
                );
            }
            buildNostrStatus() { this.$el.append($('<h3>Nostr Status</h3>'), $('<div id="nostr-connection-status">Connecting...</div>'), $('<hr>')); }
            buildNostrFeed() { this.$el.append($('<h3>Nostr Feed</h3>'), $('<div id="nostr-feed" style="max-height: 150px; overflow-y: auto;"></div>')); }
        }

        // Simple View Class
        class SimpleView {
            constructor(title, content) {
                this.$el = $(`<div class="view" style="display: none;"><h2>${title}</h2><p>${content}</p></div>`);
            }
        }

        // Database View Class
        class DatabaseView {
            constructor() {
                this.$el = $('<div id="database-view" class="view active"></div>');
                this.$filterBar = $(`<div class="filter-bar">
          <input type="text" id="search-input" placeholder="Search TODOs..." />
          <button id="search-btn">Search</button>
        </div>`);
                this.$objectList = $('<div id="object-list"></div>');
                this.$newObjectBtn = $('<button id="new-object-btn">New TODO</button>');
                this.$editorContainer = $(`
          <div id="editor-container" style="display: none;">
            <div class="toolbar">
              <button id="bold-btn"><b>B</b></button>
              <button id="italic-btn"><i>I</i></button>
              <button id="insert-tag-btn">Insert Tag</button>
            </div>
            <div id="editor" contenteditable="true"></div>
            <div class="metadata-panel">
              <label for="object-name">Name:</label>
              <input type="text" id="object-name" />
            </div>
            <button id="save-object-btn">Save</button>
            <button id="cancel-edit-btn">Cancel</button>
          </div>
        `);
                this.$el.append(this.$filterBar, this.$objectList, this.$newObjectBtn, this.$editorContainer);
            }
        }

        // Main Content Class
        class MainContent {
            constructor() {
                this.$el = $('<div class="main-content"></div>').append($('<div class="content"></div>'));
                this.views = {
                    'database-view': new DatabaseView(),
                    'me-view': new SimpleView('User Profile', 'Your personal profile and settings.'),
                    'friends-view': new SimpleView('Friends', 'Friend activity and connection updates.'),
                    'network-view': new SimpleView('Network Activity', 'Relay messages and network events.'),
                    'settings-view': new SimpleView('Settings', 'Application configuration.')
                };
                _.forEach(this.views, view => this.$el.find('.content').append(view.$el));
            }
            showView(viewName) {
                this.$el.find('.view').removeClass('active').hide();
                this.views[viewName]?.$el.addClass('active').show();
            }
        }

        // Matcher Class
        class Matcher {
            constructor(app) { this.app = app; }
            async matchEvent(ev) {
                const eventText = ev.content.toLowerCase();
                const matches = [];
                const objs = await this.app.store.getAll();
                for (const obj of objs) {
                    const $temp = $('<div></div>').html(obj.content);
                    let objMatched = false;
                    let allTagsMustMatch = false;
                    let matchedTagCount = 0;
                    $temp.find('.inline-tag').each((index, element) => {
                        const $this = $(element);
                        const tagName = $this.find('.tag-name').text();
                        const tagDef = findTagDefinition(tagName);
                        if (!tagDef) return;
                        const condition = $this.find('.tag-condition').text().trim();
                        let tagMatched = false;
                        if (condition.includes("between")) {
                            const lower = parseFloat($this.find('input.lower').val());
                            const upper = parseFloat($this.find('input.upper').val());
                            const numbersInEvent = eventText.match(/\d+/g)?.map(Number) || [];
                            tagMatched = numbersInEvent.some(num => !isNaN(lower) && !isNaN(upper) && num >= lower && num <= upper);
                        } else {
                            const tagVal = $this.find('input.tag-value').val()?.toLowerCase();
                            if (tagVal) {
                                tagMatched = (condition === "is exactly") ? eventText === tagVal : eventText.includes(tagVal);
                            }
                        }
                        if (tagMatched) matchedTagCount++;
                    });
                    objMatched = allTagsMustMatch ? matchedTagCount === $temp.find('.inline-tag').length : matchedTagCount > 0;
                    if (objMatched) matches.push(obj);
                }
                if (matches.length > 0) {
                    this.app.notifyMatch(matches, ev);
                }
            }
        }

        // NObjectStore Class (using idb-keyval)
        class NObjectStore {
            async getAll() {
                try {
                    const allKeys = await idbKeys();
                    const allObjs = await Promise.all(allKeys.map(key => get(key)));
                    return _.orderBy(allObjs.filter(obj => obj != null), ['updatedAt'], ['desc']);
                } catch (error) {
                    console.error("Error getting all objects:", error);
                    alert("Failed to retrieve data. IndexedDB might be unavailable.");
                    return [];
                }
            }
            async save(o) {
                if (!o.id) {
                    console.error("Attempted to save an object without an id:", o);
                    throw new Error("Missing id property on object");
                }
                try {
                    await set(o.id, o);
                    return o;
                } catch (error) {
                    console.error("Error saving object:", error);
                    alert("Failed to save data. IndexedDB might be unavailable.");
                    throw error;
                }
            }
            async delete(id) {
                try {
                    await del(id);
                } catch(error){
                    console.error("Error deleting object:", error);
                    alert("Failed to delete data. IndexedDB might be unavailable.");
                }
            }
        }

        // Nostr Client Class
        class NostrClient {
            constructor(matcher) {
                this.matcher = matcher;
                this.relayUrl = "wss://relay.damus.io";
                this.relay = relayInit(this.relayUrl);
                this.setupRelayEvents();
                this.relay.connect();
            }

            setupRelayEvents() {
                this.relay.on("connect", () => {
                    console.log("Connected to relay");
                    $("#nostr-connection-status").text("Connected");
                    this.subscribe();
                    this.subscribeFeed();
                });
                this.relay.on("error", (err) => {
                    console.error("Relay error", err);
                    $("#nostr-connection-status").text(`Error: ${err}`);
                });
                this.relay.on("disconnect", () => {
                    console.log("Disconnected");
                    $("#nostr-connection-status").text("Disconnected");
                });
            }

            subscribe() {
                this.relay.sub([{ kinds: [30000] }]).on("event", (ev) => {
                    try {
                        // Only process events whose content appears to be valid JSON.
                        if (!ev.content || ev.content.trim()[0] !== '{') {
                            //console.warn("Invalid JSON content received:", ev.content);
                            return;
                        }
                        const data = JSON.parse(ev.content);
                        if (!data.id)
                            return; //???

                        const sanitizedContent = DOMPurify.sanitize(data.content);
                        window.app.store.getAll().then(allObjs => {
                            const existingObj = allObjs.find(o => o.id === data.id);
                            const nobj = existingObj
                                ? { ...existingObj, name: data.name, content: sanitizedContent, tags: ev.tags.filter(t => t[0] === "t").map(t => t[1]), updatedAt: ev.created_at * 1000 }
                                : { id: data.id, name: data.name, content: sanitizedContent, tags: ev.tags.filter(t => t[0] === "t").map(t => t[1]), createdAt: ev.created_at * 1000, updatedAt: ev.created_at * 1000 };
                            window.app.store.save(nobj).then(() => window.app.renderList());
                        });
                    } catch (e) {
                        console.error("Parsing error", e);
                    }
                });
            }

            subscribeFeed() {
                this.relay.sub([{ kinds: [1] }]).on("event", (ev) => {
                    const timeStr = dateFns.format(new Date(ev.created_at * 1000), 'p');
                    $("#nostr-feed")
                        .prepend(`<div>[${timeStr}] ${ev.pubkey}: ${DOMPurify.sanitize(ev.content)}</div>`)
                        .children(':gt(19)').remove();
                    this.matcher.matchEvent(ev);
                });
            }

            publish(nobj) {
                const sanitizedContent = DOMPurify.sanitize(nobj.content);
                const content = JSON.stringify({ id: nobj.id, name: nobj.name, content: sanitizedContent });
                const ev = {
                    pubkey: window.keys.pub,
                    created_at: Math.floor(nobj.updatedAt / 1000),
                    kind: 30000,
                    tags: nobj.tags.map(tag => ["t", tag]),
                    content
                };
                ev.id = getEventHash(ev);
                ev.sig = signEvent(ev, window.keys.priv);
                this.relay.publish(ev);
            }
        }

        // Main App Class
        class App {
            constructor() {
                this.store = new NObjectStore();
                this.selected = null;
                this.$editor = $("#editor");
                this.$objectNameInput = $("#object-name");
                this.matcher = new Matcher(this);
                this.debouncedRenderList = _.debounce(() => this.renderList(), 300);
                this.initUI();
                this.renderList();
            }
            async initUI() {
                this.$container = $('<div class="container"></div>');
                this.sidebar = new Sidebar();
                this.mainContent = new MainContent();
                this.$container.append(this.sidebar.$el, this.mainContent.$el);
                $("body").append(
                    this.$container,
                    $('<div id="notification-area"></div>'),
                    $('<div class="loading-overlay"><div class="spinner"></div></div>')
                );
                try {
                    await this.ensureKeysLoaded();
                    this.setupEventHandlers();
                } catch (error) {
                    console.error("Error initializing UI:", error);
                }
            }
            async ensureKeysLoaded() {
                if (!window.keys) {
                    await getKeys();
                }
            }
            setupEventHandlers() {
                this.sidebar.$el.on("click", "a[data-view]", (e) => { e.preventDefault(); this.setView($(e.currentTarget).data("view")); });
                this.sidebar.$el.on("click", "a[data-list]", (e) => {
                    e.preventDefault();
                    if ($(e.currentTarget).data("list") === "recent") {
                        this.setView("database-view");
                        this.renderList();
                    }
                });
                $("#search-btn").on("click", () => this.debouncedRenderList($("#search-input").val()));
                $("#new-object-btn").on("click", () => this.createNewObject());
                $("#save-object-btn").on("click", () => this.saveObject());
                $("#cancel-edit-btn").on("click", () => this.hideEditor());
                $("#bold-btn").on("click", () => document.execCommand("bold"));
                $("#italic-btn").on("click", () => document.execCommand("italic"));
                $("#insert-tag-btn").on("click", (e) => this.showTagMenu(e));
                $("#object-list").on("click", ".object-item", async (e) => {
                    const id = $(e.currentTarget).data("id");
                    try {
                        const objs = await this.store.getAll();
                        const objToEdit = _.find(objs, { id });
                        if (objToEdit) {
                            this.editObject(objToEdit);
                        }
                    } catch (error) {
                        console.error("Error editing object: ", error);
                    }
                });
                this.$editor.on("mouseup keyup", () => {
                    const sel = window.getSelection();
                    if (sel?.rangeCount > 0) {
                        window.savedRange = sel.getRangeAt(0);
                    }
                });
                $(document).on("click", (e) => {
                    if (!$(e.target).closest("#editor").length) {
                        $(".inline-tag .tag-controls").css("visibility", "hidden");
                    }
                });
            }
            setView(v) {
                this.mainContent.showView(v);
                if (v !== "database-view") this.hideEditor();
            }
            async renderList(filter = "") {
                const $list = $("#object-list");
                try {
                    const objs = await this.store.getAll();
                    let filteredObjs = objs;
                    if (filter.trim()) {
                        const regex = new RegExp(_.escapeRegExp(filter), 'i');
                        filteredObjs = _.filter(objs, (o) => regex.test(o.name) || regex.test(o.content));
                    }
                    $list.empty().append(filteredObjs.length
                        ? _.map(filteredObjs, o => this.renderObjectItem(o))
                        : '<p>No TODO items found.  Click "New TODO" to create one.</p>');
                } catch (error) {
                    console.error("Error rendering list: ", error);
                }
            }
            renderObjectItem(o) {
                const safeContent = DOMPurify.sanitize(o.content);
                const updatedStr = o.updatedAt ? dateFns.format(o.updatedAt, 'Pp') : "?";
                return $(`
          <div class="object-item" data-id="${o.id}">
            <strong>${o.name}</strong>
            <div>${safeContent}</div>
            <small>Updated: ${updatedStr}</small>
          </div>
        `);
            }
            createNewObject() {
                this.showEditor({ id: nanoid.nanoid(), name: "", content: "", tags: [], createdAt: Date.now(), updatedAt: Date.now() });
            }
            editObject(o) {
                this.selected = o;
                this.showEditor(o);
            }
            showEditor(o) {
                this.$objectNameInput.val(o.name);
                this.$editor.html(DOMPurify.sanitize(o.content));
                $("#editor-container").show();
            }
            hideEditor() {
                $("#editor-container").hide();
                this.selected = null;
            }
            async saveObject() {
                const name = this.$objectNameInput.val();
                const content = this.$editor.html();
                if (!name.trim()) {
                    alert("Name cannot be empty");
                    return;
                }
                const now = Date.now();
                const sanitizedContent = DOMPurify.sanitize(content);
                const o = this.selected
                    ? { ...this.selected, name, content: sanitizedContent, updatedAt: now }
                    : { id: nanoid.nanoid(), name, content: sanitizedContent, tags: [], createdAt: now, updatedAt: now };
                try {
                    await this.store.save(o);
                    this.hideEditor();
                    this.renderList();
                    nostrClient.publish(o);
                } catch (error) {
                    console.error("Error in App.saveObject:", error);
                }
            }
            showTagMenu(e) {
                const $menu = $("#tag-menu").empty();
                const $searchInput = $('<input type="text" placeholder="Search tags...">').appendTo($menu);
                const renderTagList = () => {
                    $menu.find('ul, strong').remove();
                    const filterText = $searchInput.val().toLowerCase();
                    _.forEach(ontology, (tags, cat) => {
                        const filteredTags = _.pickBy(tags, (tagDef, tagName) => _.includes(tagName.toLowerCase(), filterText));
                        if (!_.isEmpty(filteredTags)) {
                            $menu.append(`<strong>${cat}</strong>`);
                            const $ul = $("<ul></ul>");
                            _.forEach(filteredTags, (tagDef, tag) => {
                                const $li = $(`<li>${tag}</li>`).on("click", () => {
                                    const widget = new InlineTagWidget(tag, tagDef.defaultCondition, "", _.first(tagDef.allowedNatures));
                                    insertNodeAtCursor(widget.$el);
                                    $menu.hide();
                                });
                                $ul.append($li);
                            });
                            $menu.append($ul);
                        }
                    });
                }
                $searchInput.on('input', renderTagList);
                renderTagList();
                let top = e.pageY + 5;
                let left = e.pageX + 5;
                $menu.css({ top: 0, left: 0, display: "block" });
                const { width: menuWidth, height: menuHeight } = $menu[0].getBoundingClientRect();
                $menu.hide();
                const { width: windowWidth, height: windowHeight } = document.documentElement.getBoundingClientRect();
                left = Math.max(10, Math.min(left, windowWidth - menuWidth - 10));
                top = Math.max(10, Math.min(top, windowHeight - menuHeight - 10));
                $menu.css({ top, left, display: "block" });
                const handleMenuKeydown = (event) => {
                    if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                        event.preventDefault();
                        let $items = $menu.find('li:visible');
                        let $current = $items.filter('.selected');
                        let $next = (event.key === 'ArrowDown')
                            ? ($current.removeClass('selected').nextAll('li:visible:first').length > 0 ? $current.removeClass('selected').nextAll('li:visible:first') : $items.first())
                            : ($current.removeClass('selected').prevAll('li:visible:first').length > 0 ? $current.removeClass('selected').prevAll('li:visible:first') : $items.last());
                        if($next.length === 0 && $items.length > 0){
                            $next = (event.key === 'ArrowDown') ? $items.first() : $items.last();
                        }
                        $next.addClass('selected');
                    } else if (event.key === 'Enter') {
                        event.preventDefault();
                        $menu.find('li:visible.selected').click();
                    }
                };
                $menu.on('keydown', handleMenuKeydown);
                $(document).one("click", (ev) => {
                    if (!$(ev.target).closest("#tag-menu, #insert-tag-btn").length) {
                        $menu.hide().off('keydown', handleMenuKeydown);
                    }
                });
                setTimeout(() => $searchInput.focus(), 0);
            }
            notifyMatch(matchedObjects, ev) {
                const formattedDate = dateFns.format(new Date(), 'Pp');
                const msg = `Match found in ${matchedObjects.length} object(s) for event from ${ev.pubkey}:<br>
                     ${_.map(matchedObjects, (obj) => `<em>${obj.name}</em> (updated ${dateFns.format(obj.updatedAt, 'Pp')})`).join('<br>')}`;
                this.$notificationArea.html(msg).fadeIn(300).delay(3000).fadeOut(300);
            }
            showLoading() { $(".loading-overlay").show(); }
            hideLoading() { $(".loading-overlay").hide(); }
        }

        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', async () => {
            const app = new App();
            const loadedKeys = await getKeys();
            if (loadedKeys) {
                // Make the app and keys globally available so that NostrClient can use them.
                window.app = app;
                window.keys = loadedKeys;
                window.nostrClient = new NostrClient(app.matcher);
            } else {
                // Handle key loading errors appropriately.
            }
        });
    </script>
</head>
<body>
<!-- The UI is built dynamically -->
<!-- Tag Insertion Menu (hidden by default) -->
<div id="tag-menu"></div>
</body>
</html>
